/*
 * Gradle file to build the Jar Resolver Unity plugin.
 */
buildscript {
    repositories {
        jcenter()
        mavenLocal()
    }
}

/*
 * Project level variables
 */
project.ext {
    sdk_root = System.getProperty("ANDROID_HOME")
    if (sdk_root == null || sdk_root.isEmpty()) {
        sdk_root = System.getenv("ANDROID_HOME")
    }

    // Determine the current OS.
    os_name = System.getProperty("os.name").toLowerCase();
    os_osx = os_name.contains("mac os x");
    os_windows = os_name.contains("windows");
    os_linux = os_name.contains("linux");

    // Search for the Unity editor executable.
    // The Unity editor is required to package the plug-in.
    unity_exe = System.getProperty("UNITY_EXE")
    if (unity_exe == null || unity_exe.isEmpty()) {
        unity_exe = System.getenv("UNITY_EXE")
    }
    if (unity_exe == null || unity_exe.isEmpty()) {
      // TODO: Should probably also search the path using Exec / which / where.
      if (os_osx) {
        unity_exe ='/Applications/Unity/Unity.app/Contents/MacOS/Unity'
      } else if (os_windows) {
        unity_exe = 'C:\\Program Files\\Unity\\Editor\\Unity.exe'
      } else if (os_linux) {
        unity_exe = '/opt/Unity/Editor/Unity'
      }
    }
    unity_exe_found = (new File(unity_exe)).exists();
    if (!unity_exe_found) {
      logger.warn('Unity editor executable not found, plug-in packaging ' +
                  'may fail.')
    }

    // Get the path to the Unity DLLs.
    // Unity DLLs are referenced by the plug-in and therefore required by the
    // build process.
    unity_dll_path = System.getProperty("UNITY_DLL_PATH")
    unity_dll_path_file = (unity_dll_path == null ||
                           unity_dll_path.isEmpty()) ?
                          null : new File(unity_dll_path);
    if ((unity_dll_path_file == null || !unity_dll_path_file.exists()) &&
        unity_exe_found) {
      if (os_osx) {
        // Search paths relative to the Unity binary for the Managed
        // directory.
        for (path in ['../Frameworks/Managed', '../Managed']) {
          unity_dll_path_file = new File(new File(unity_exe).getParentFile(),
                                         path)
          if (unity_dll_path_file.exists()) break;
        }
      } else if (os_windows || os_linux) {
        // ${unity_exe}/../Data/Managed/Unity{Engine,Editor}.dll
        unity_dll_path_file = new File(
            (new File(unity_exe)).getParentFile(),
            'Data' + File.separator + 'Managed')
      }
      if (unity_dll_path_file != null && unity_dll_path_file.exists()) {
        unity_dll_path = unity_dll_path_file.getPath()
      }
    }
    if (unity_dll_path_file == null || !unity_dll_path_file.exists()) {
      logger.error('Unity DLLs not found, plug-in build will fail.')
    }

    unity_playback_engines_dll_path = System.getProperty(
      "UNITY_PLAYBACK_ENGINES_DLL_PATH")
    unity_playback_engines_dll_path_file = (
      unity_playback_engines_dll_path == null ||
      unity_playback_engines_dll_path.isEmpty()) ? null : (
        new File(unity_playback_engines_dll_path))
    if ((unity_playback_engines_dll_path_file == null ||
         !unity_playback_engines_dll_path_file.exists()) &&
        unity_exe_found) {
      if (os_osx) {
        // ${unity_exe}/../../../../PlaybackEngines
        unity_playback_engines_dll_path_file = new File(
          (new File(unity_exe))
              .getParentFile()
              .getParentFile()
              .getParentFile()
              .getParentFile(),
          'PlaybackEngines')
        println unity_playback_engines_dll_path_file.getPath()
      } else if (os_windows) {
        // ${unity_exe}/../Data/PlaybackEngines
        unity_playback_engines_dll_path_file = new File(
            (new File(unity_exe)).getParentFile(),
            'Data' + File.separator + 'PlaybackEngines')
      }
      if (unity_playback_engines_dll_path_file != null &&
          unity_playback_engines_dll_path_file.exists()) {
        unity_playback_engines_dll_path =
          unity_playback_engines_dll_path_file.getPath()
      }
    }
    if (unity_playback_engines_dll_path_file == null ||
        !unity_playback_engines_dll_path_file.exists()) {
      logger.error('Unity Playback Engine DLLs not found, iOS plug-in build ' +
                   'will fail.')
    }

    // Mono's xbuild tool is required to build the managed DLLs in the plug-in.
    xbuild_exe = System.getProperty("XBUILD_EXE")
    if (xbuild_exe == null || xbuild_exe.isEmpty()) {
        xbuild_exe = System.getenv("XBUILD_EXE")
    }
    if (xbuild_exe == null || xbuild_exe.isEmpty()) {
        xbuild_exe = 'xbuild'
    }
    if (!(new File(xbuild_exe)).exists()) {
      logger.warn('xbuild not found, plug-in build may fail.')
    }

    pluginSrc = file('plugin').absolutePath
    pluginProj = file('build/PluginSrc').absolutePath
    buildPath = file('build').absolutePath
    exportPath = file('build/plugin.unitypackage').absolutePath
    dllDir = 'Assets/PlayServicesResolver/Editor'
    pluginVersion = '1.2.1.1'
    currentPluginPath = file('.').absolutePath
    currentPluginBasename = 'play-services-resolver'
    currentPluginName = (currentPluginBasename + '-' + pluginVersion +
                         '.unitypackage')
}

task compile_resolverTests(type: Exec) {
  description 'Compile the tests for the Mono framework component.'
  workingDir 'source'
  commandLine "${xbuild_exe}", '/target:JarResolverTests'
  ext.remoteTaskPhase = 'prebuild'
}

task test_resolverLib(type: Exec, dependsOn: compile_resolverTests) {
  description 'Runs the tests.'
  workingDir 'source'
  commandLine "nunit-console",
              "JarResolverTests/bin/Debug/JarResolverTests.dll"
  ext.remoteTaskPhase = 'prebuild'
}

task copy_unityDlls(type: Copy) {
  description 'Copy Unity DLLs required to build managed DLLs in the plugin.'
  from files(new File(project.ext.unity_dll_path_file, 'UnityEngine.dll'),
             new File(project.ext.unity_dll_path_file, 'UnityEditor.dll'),
             new File((File)project.ext.unity_playback_engines_dll_path_file,
                      'iOSSupport' + File.separator +
                      'UnityEditor.iOS.Extensions.Xcode.dll'))
  into 'unity_dlls'
  ext.remoteTaskPhase = 'prebuild'
}

// Construct the name of a versioned asset from the source filename and version
// string.
// The encoded string takes the form...
// ${filename}_v${version}_.${extension}
// where extension is derived from the specified filename.
def versionedAssetName(filename, version) {
  def extensionIndex = filename.lastIndexOf('.')
  def basename = filename.substring(0, extensionIndex)
  def extension = filename.substring(extensionIndex)
  // Encode the DLL version and target names into the DLL in the form...
  // ${dllname}_t${hypen_separated_target_names}_v${version}.dll
  def targetName = basename
  if (version != null && !version.isEmpty()) {
    targetName += '_v' + version
  }
  return targetName + extension
}

// Generate the tasks to compile a plugin DLL and copy it to the Unity
// plugin packaging folder.
def build_pluginDll(projectName, assemblyDllBasename) {
  def version = "${pluginVersion}"
  def projectPath = 'source/' + projectName + '/' + projectName + '.csproj'
  def assemblyDll = versionedAssetName(assemblyDllBasename, version)

  def compileTask = tasks.create(name: "compile_" + projectName,
                                 type: Exec,
                                 description: 'Compile ' + projectName,
                                 dependsOn: [copy_unityDlls])
  compileTask.workingDir('source')
  compileTask.commandLine(["${xbuild_exe}", "/target:" + projectName])
  compileTask.ext.remoteTaskPhase = "prebuild"
  def assemblyDllSource = file("source/" + projectName + "/bin/Debug/" +
                               assemblyDllBasename)

  def dllMetaBasename = assemblyDllBasename + ".meta"
  def dllMeta = "${pluginSrc}/${dllDir}/" + dllMetaBasename
  def dllMetaVersioned = assemblyDll + ".meta"
  def copyTask = tasks.create(name: "copy_" + projectName,
                              type: Copy,
                              description: ('Copy ' + projectName +
                                            ' to unity packaging folder'),
                              dependsOn: compileTask)
  copyTask.from(files(assemblyDllSource, dllMeta))
  copyTask.into("${pluginProj}/${dllDir}")
  copyTask.duplicatesStrategy('include')
  copyTask.rename({
                    String fn ->
                      if (fn.endsWith(dllMetaBasename)) {
                        return fn.replace(dllMetaBasename, dllMetaVersioned)
                      } else if (fn.endsWith(assemblyDllBasename)) {
                        return fn.replace(assemblyDllBasename, assemblyDll)
                      }
                      return fn
                  })
  copyTask.ext.remoteTaskPhase = "prebuild"
}

build_pluginDll("PlayServicesResolver", "Google.JarResolver.dll")
build_pluginDll("VersionHandler", "Google.VersionHandler.dll")
build_pluginDll("IOSResolver", "Google.IOSResolver.dll")

task update_metadataForVersion() {
  description 'Update plugin metadata if the plugin version changed.'
  if (!file(currentPluginName).exists()) {
    for (fileobj in fileTree("${pluginSrc}")) {
      def lines = fileobj.text.split('\n')
      def outputLines = []
      for (line in lines) {
        if (line.contains('guid:')) {
          line = (
            'guid: ' + java.util.UUID.randomUUID().toString().replace('-', ''))
        }
        outputLines.add(line)
      }
      fileobj.write(outputLines.join('\n') + '\n')
    }
  }
}

task copy_pluginTemplate(type: Copy, dependsOn: update_metadataForVersion) {
  description 'Copy the template project into the Unity plugin packaging dir.'
  from "${pluginSrc}"
  into "${pluginProj}"
  exclude '**/*.dll.*', '**/*.txt.meta'
  duplicatesStrategy 'include'
  ext.remoteTaskPhase = 'prebuild'
}

task inject_versionIntoMetaFiles(dependsOn: [copy_pluginTemplate,
                                             'copy_PlayServicesResolver',
                                             'copy_VersionHandler',
                                             'copy_IOSResolver']) {
  description 'Inject the version number into the plugin\'s meta files.'
  ext.remoteTaskPhase = 'prebuild'
  doLast {
    for (fileobj in fileTree("${pluginProj}")) {
      if (fileobj.path.endsWith('.meta')) {
        def lines = fileobj.text.split('\n')
        def outputLines = []
        for (line in lines) {
          outputLines.add(line)
          if (line.contains('labels:')) {
            outputLines.add("- gvh_v${pluginVersion}")
          }
        }
        fileobj.write(outputLines.join('\n') + '\n')
      }
    }
  }
}

task copy_manifestMetadata(type: Copy) {
  def manifestBasename = versionedAssetName(
    currentPluginBasename + '.txt', null) + '.meta'
  description 'Copy .meta file for the plugin manifest.'
  from file("${pluginSrc}/${dllDir}/" + manifestBasename)
  into file("${pluginProj}/${dllDir}/")
  rename {
    String fn ->
      return fn.replace(manifestBasename,
                        versionedAssetName(currentPluginBasename + '.txt',
                                           "${pluginVersion}") +
                        '.meta')
  }
  ext.remoteTaskPhase = 'prebuild'
}

task generate_manifest(dependsOn: ['copy_manifestMetadata',
                                   'inject_versionIntoMetaFiles']) {
  description 'Generate a manifest for the files in the plug-in.'
  doLast {
    def dir = file("${pluginProj}/Assets")
    def list = []
    dir.eachFileRecurse(groovy.io.FileType.FILES) { filename ->
      def path = filename.path
      if (!(path.toLowerCase().endsWith('.meta') ||
            path.toLowerCase().endsWith('.txt'))) {
        list << filename.path.replace("${pluginProj}/", '')
      }
    }
    def manifest = file("${pluginProj}/${dllDir}/" +
                        versionedAssetName(currentPluginBasename + '.txt',
                                           "${pluginVersion}"))
    manifest.write(list.join('\n') + '\n')
  }
  ext.remoteTaskPhase = 'prebuild'
}

task export_package(dependsOn: 'generate_manifest') {
  description 'Creates and exports the Plugin unity package.'
  doLast {
    def argv = ["-g.building",
                "-buildTarget",
                "android",
                "-batchmode",
                "-projectPath",
                "${pluginProj}",
                "-logFile",
                "build/unity.log",
                "-exportPackage",
                "Assets/PlayServicesResolver",
                "${exportPath}",
                "-quit"]
    exec {
      executable "${unity_exe}"
      args argv
    }
  }
  ext.remoteTaskPhase = 'build'
}

task copy_plugin(dependsOn: 'export_package') {
  description 'Copy plugin to the current-build directory'
  doFirst {
    // If the version number has been bumped delete the exploded directory.
    if (!file(currentPluginName).exists()) {
      delete file(currentPluginPath +"/exploded")
    }

    copy {
      from file(exportPath)
      into file(currentPluginPath)
      rename ('plugin.unitypackage', currentPluginName)
    }
  }
  doLast {
    copy {
      from file("${pluginProj}")
      into file(currentPluginPath +"/exploded")
      include "Assets/PlayServicesResolver/**/*"
    }
  }
  ext.remoteTaskPhase = 'postbuild'
}

task build_unityPackage(dependsOn: 'copy_plugin') {
  description "Top level task for building the unity package."
  doLast { println "Packaging Complete!" }
  ext.remoteTaskPhase = 'build'
  dependsOn {
    tasks.findAll { task -> task.name.startsWith('PackageSample') }
  }
}

defaultTasks = ['prebuild', 'build', 'postbuild']
for (phase in defaultTasks) {
  if (!tasks.findByName(phase)) {
    def build_phase_name = 'Local ' + phase
    tasks.create(name: phase,
                 action: { println(build_phase_name) },
                 description: build_phase_name,
                 dependsOn: project.tasks.findAll {
                   task -> task.ext.has('remoteTaskPhase') &&
                   task.ext.remoteTaskPhase == phase
                 })
  }
}
project.defaultTasks = defaultTasks
