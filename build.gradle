/*
 * Gradle file to build the Jar Resolver Unity plugin.
 */
buildscript {
  repositories {
    mavenCentral()
    mavenLocal()
  }
}

plugins {
  id "com.jetbrains.python.envs" version "0.0.30"
}

/*
 * Project level variables
 */
project.ext {
  // Set of properties to cache in the project.properties file.
  Properties cacheProperties = new Properties()

  // Set of directories to *not* search under the Unity root directory when
  // searching for components of Unity.
  String unitySearchDirExcludesString = findProperty("UNITY_EXCLUDES")
  String[] unitySearchDirExcludes =
    unitySearchDirExcludesString ?
      unitySearchDirExcludesString.tokenize(";") : []

  // Save the current OS.
  operatingSystem = OperatingSystem.getOperatingSystem()

  // Default installation path for Unity based upon the host operating system.
  List<String> defaultUnityPaths =
    [(OperatingSystem.UNKNOWN): ["Unity"],
     (OperatingSystem.MAC_OSX):
     ["/Applications/Unity/Unity.app/Contents/MacOS/Unity"] +
     (new FileNameFinder()).getFileNames(
       "/", "Applications/Unity/Hub/Editor/*/Unity.app/Contents/MacOS/Unity"),
     (OperatingSystem.WINDOWS):
     ["\\Program Files\\Unity\\Editor\\Unity.exe"] +
     (new FileNameFinder()).getFileNames(
       "\\", "Program Files\\Unity\\Hub\\Editor\\*\\Editor\\Unity.exe"),
     (OperatingSystem.LINUX): ["/opt/Unity/Editor/Unity"]][operatingSystem]

  // Search for the Unity editor executable.
  // The Unity editor is required to package the plug-in.
  for (defaultUnityPath in defaultUnityPaths) {
    unityExe = findFileProperty("UNITY_EXE", new File(defaultUnityPath), false)
    if (unityExe != null && unityExe.exists()) break;
  }
  if (unityExe == null || !unityExe.exists()) {
    unityExe = findFileInPath(unityExe.name)
  }
  if (unityExe == null) {
    throw new StopActionException("Unity editor executable (UNITY_EXE) not " +
                                  "found")
  }
  saveProperty("UNITY_EXE", unityExe, cacheProperties)

  // Path fragment that is the parent of the unity executable install location.
  // This is used to find the unity root directory from the editor executable.
  String unityExeParentPath =
    [(OperatingSystem.UNKNOWN): "Editor",
     (OperatingSystem.MAC_OSX): "Unity.app/Contents/MacOS",
     (OperatingSystem.WINDOWS): "Editor",
     (OperatingSystem.LINUX): "Editor"][operatingSystem]
  File unityRootDir = findFileProperty(
    "UNITY_DIR", new File(unityExe.parentFile.absolutePath -
                          unityExeParentPath), true)
  if (unityRootDir == null) {
    throw new StopActionException("Unity root directory (UNITY_DIR) not found.")
  }
  saveProperty("UNITY_DIR", unityRootDir, cacheProperties)

  FileTree unityRootDirTree = fileTree(dir: unityRootDir)

  // Find unity engine dll under the root directory.
  unityDllPath = getFileFromPropertyOrFileTree(
    "UNITY_DLL_PATH", true, {
      unityRootDirTree.matching {
        include "**/Managed/UnityEngine.dll"
        exclude unitySearchDirExcludes
      }
    })
  if (unityDllPath == null) {
    throw new StopActionException(
      "UnityEngine.dll and UnityEditor.dll directory (UNITY_DLL_PATH) " +
      "not found.")
  }
  saveProperty("UNITY_DLL_PATH", unityDllPath, cacheProperties)

  // iOS runtime dll.  This is with the playback engine, so the
  // structure is different for MacOS and the others.
  unityIosPath = getFileFromPropertyOrFileTree(
    "UNITY_IOS_PLAYBACK_PATH", true, {
      unityRootDirTree.matching {
        include "**/PlaybackEngines/iOSSupport/UnityEditor.iOS.Extensions.dll",
        "**/PlaybackEngines/iossupport/UnityEditor.iOS.Extensions.dll"
        exclude unitySearchDirExcludes
      }
    })
  if (unityIosPath == null) {
    // iOS support is *required* to build the iOS resolver.
    throw new StopActionException(
      "UnityEditor.iOS.Extensions.dll directory (UNITY_IOS_PLAYBACK_PATH) " +
      "not found.")
  }
  saveProperty("UNITY_IOS_PLAYBACK_PATH", unityIosPath, cacheProperties)

  // Find xbuild to build the dlls.
  xbuildExe = getFileFromPropertyOrFileTree(
    "XBUILD_EXE", false, {
      unityRootDirTree.matching {
        include (operatingSystem == OperatingSystem.WINDOWS ?
                 "**/bin/xbuild.bat" : "**/xbuild")
        exclude unitySearchDirExcludes
      }
    })
  if (xbuildExe == null) {
    throw new StopActionException("xbuild not found (XBUILD_EXE)")
  }
  saveProperty("XBUILD_EXE", xbuildExe, cacheProperties)

  // Find mono to determine the distribution being used.
  monoExe = getFileFromPropertyOrFileTree(
    "MONO_EXE", false, {
      unityRootDirTree.matching {
        include (operatingSystem == OperatingSystem.WINDOWS ?
          "**/bin/mono.bat" : "**/bin/mono")
        exclude unitySearchDirExcludes
      }
    })
  saveProperty("MONO_EXE", monoExe, cacheProperties)

  // Get the mono distribution version.
  def versionRegEx = /^.* version ([^ ]+) .*/
  def stdout = new ByteArrayOutputStream()
  exec {
    commandLine monoExe, "-V"
    ignoreExitValue true
    standardOutput = stdout
  }
  def monoVersionList =
    stdout.toString().replace("\r\n", "\n").tokenize("\n").findResults {
      def versionMatch = it =~ versionRegEx
      if (versionMatch.matches()) {
        return versionMatch.group(1)
      }
      return null
    }
  if (!monoVersionList) {
    throw new StopActionException(
      sprintf("Unable to determine mono version from %s", monoExe))
  }
  monoVersion = monoVersionList[0]

  // Mono 5.x and above generate .pdb files that are compatible with visual
  // studio as opposed to the mono-specific .pdb files.
  pdbSupported = monoVersion.tokenize(".")[0].toInteger() >= 5

  if (pdbSupported) {
    logger.warn(
      sprintf("Mono %s detected which will generate .pdb files " +
              "that are not compatible with older versions of Unity. " +
              "This can be fixed by compiling with Unity 5.6.",
              monoVersion))
  }

  // Find the NUnit framework dll.
  unityNUnitDll = getFileFromPropertyOrFileTree(
    "UNITY_NUNIT_PATH", true, {
      unityRootDirTree.matching {
        include "**/nunit.framework.dll"
        exclude unitySearchDirExcludes
      }
    })
  if (unityNUnitDll == null) {
    logger.warn("Unity NUnit DLL not found, tests will not build.")
  }
  saveProperty("UNITY_NUNIT_PATH", unityNUnitDll, cacheProperties)

  // nunit-console is used to run tests.
  nunitConsoleExe = getFileFromPropertyOrFileTree(
    "NUNIT_CONSOLE_EXE", false, {
      unityRootDirTree.matching {
        include (operatingSystem == OperatingSystem.WINDOWS ?
                 "**/bin/nunit-console2.bat" :
                 "**/nunit-console2")
        exclude unitySearchDirExcludes
      }
    })
  if (nunitConsoleExe == null) {
    logger.warn("nunit_console not found (NUNIT_CONSOLE_EXE) C# unit test " +
                "execution will fail.")
  }
  saveProperty("NUNIT_CONSOLE_EXE", nunitConsoleExe, cacheProperties)

  // Get the directory that contains this script.
  scriptDirectory = buildscript.sourceFile.getParentFile()

  // It can take a while to search for build tools, so cache paths in the project
  // properties.
  File projectPropertiesFile = new File(scriptDirectory,"gradle.properties")
  if (!projectPropertiesFile.exists()) {
    logger.info(sprintf("Saving %s to %s",
                        cacheProperties.stringPropertyNames(),
                        projectPropertiesFile))
    cacheProperties.store(projectPropertiesFile.newWriter(), null)
  }

  // UnityAssetUploader required environment variables.
  unityUsername = findProperty("UNITY_USERNAME")
  unityPassword = findProperty("UNITY_PASSWORD")
  unityPackageId = findProperty("UNITY_PACKAGE_ID")
  unityPackagePath = findFileProperty("UNITY_PACKAGE_PATH", null)

  // Whether debug symbols should be included.
  debugEnabled = true

  // Whether interactive mode tests are enabled.
  interactiveModeTestsEnabled =
    findProperty("INTERACTIVE_MODE_TESTS_ENABLED", "1") == "1"

  // Directory for intermediate and final build outputs.
  buildDir = new File(scriptDirectory, "build")
  // Directory for external tools.
  externalToolsDir = new File(scriptDirectory, "external_tools")
  // Directory for testing.
  testDir = new File(scriptDirectory, "test_output")
  // Version of the plugin (update this with CHANGELOG.md on each release).
  pluginVersion = "1.2.176"
  // Directory that contains the template plugin.
  // Files under this directory are copied into the staging area for the
  // plugin.
  pluginTemplateDir = new File(scriptDirectory, "plugin")
  // Directory where the plugin is staged to be exported as a Unity package.
  pluginStagingAreaDir = new File(buildDir, "staging")
  // Directory where the build plugin is unpacked to.
  pluginExplodedDir = new File(scriptDirectory, "exploded")
  // Base filename of the released plugin.
  currentPluginBasename = "external-dependency-manager"
  // Where the exported plugin file is built before it's copied to the release
  // location.
  pluginExportFile = new File(buildDir, currentPluginBasename + ".unitypackage")
  // Where the exported UPM plugin file is built.
  pluginUpmExportFile = new File(buildDir,
                                 currentPluginBasename + pluginVersion + ".tgz")
  // Directory within the plugin staging area that just contains the plugin.
  pluginAssetsDir = new File("Assets", "ExternalDependencyManager")
  // Directories within the staging area to export.
  pluginExportDirs = [pluginAssetsDir, new File("Assets", "PlayServicesResolver")]
  // Directory within the plugin directory that contains the managed DLLs.
  pluginEditorDllDir = new File(pluginAssetsDir, "Editor")
  // Directory which contains the solution for all C# projects with a project in
  // each subdirectory.
  pluginSourceDir = new File(scriptDirectory, "source")
  // Solution which references all projects used by the plugin.
  pluginSolutionFile = new File(pluginSourceDir, "ExternalDependencyManager.sln")
  // Versioned release plugin file.
  pluginReleaseFile = new File(scriptDirectory,
                               sprintf("%s-%s.unitypackage",
                                       currentPluginBasename,
                                       pluginVersion))
  // Unversioned release plugin file.
  pluginReleaseFileUnversioned = new File(scriptDirectory,
                                          sprintf("%s-latest.unitypackage",
                                                  currentPluginBasename))

  // Location of the Unity asset uploader application.
  unityAssetUploaderDir = new File(pluginSourceDir, "UnityAssetUploader")

  // Location of the export_unity_package application.
  exportUnityPackageDir = new File(pluginSourceDir, "ExportUnityPackage")
  // Location of the import_unity_package application.
  importUnityPackageDir = new File(pluginSourceDir, "ImportUnityPackage")

  // Common arguments used to execute Unity in batch mode.
  unityBatchModeArguments = ["-batchmode", "-nographics"]
  // Common arguments used to execute Unity in interactive mode.
  unityInteractiveModeArguments = ["-gvh_noninteractive"]
  // Extension for Unity asset metadata files.
  unityMetadataExtension = ".meta"
  // Extensions for debug files.
  symbolDatabaseExtension = pdbSupported ? ".pdb" : ".dll.mdb"
  // Changelog file.
  changelog = new File(scriptDirectory, "CHANGELOG.md")
  pythonBootstrapDir = new File(externalToolsDir, "python_bootstrap")
  pythonBinDir = new File(new File(pythonBootstrapDir, "python"), "bin")
  // Python binary after it has been bootstrapped.
  pythonExe = new File(pythonBinDir, "python3")
  // Pip binary after it has been bootstrapped.
  pipExe = new File(pythonBinDir, "pip3")
  // Python packages required by export_unity_package.py
  exportUnityPackageRequirements = ["absl-py", "PyYAML", "packaging"]
  // Python packages required by gen_guids.py
  genGuidRequirements = ["absl-py"]
}

// Configure com.jetbrains.python.envs to bootstrap a Python install.
envs {
  bootstrapDirectory = project.ext.pythonBootstrapDir
  envsDirectory = new File(project.ext.buildDir, "python_envs")
  python "python", "3.9.5"
}

/*
 * Host operating system.
 */
public enum OperatingSystem {
  UNKNOWN, MAC_OSX, WINDOWS, LINUX

  /*
   * Get the current operating system.
   *
   * @returns Current host operating system.
   */
  public static OperatingSystem getOperatingSystem() {
    String os_name = System.getProperty("os.name").toLowerCase()
    if (os_name.contains("mac os x")) {
      return OperatingSystem.MAC_OSX
    } else if (os_name.contains("windows")) {
      return OperatingSystem.WINDOWS
    } else if (os_name.contains("linux")) {
      return OperatingSystem.LINUX
    }
    return OperatingSystem.UNKNOWN
  }
}

/*
 * Search the path variable for an executable file.
 *
 * @param filename Name of the file to search for.
 *
 * @return If found, the File object that references the file, null otherwise.
 */
File findFileInPath(String filename) {
  def stdout = new ByteArrayOutputStream()
  exec {
    executable OperatingSystem.getOperatingSystem() == OperatingSystem.WINDOWS ?
      "where" : "which"
    args filename
    ignoreExitValue true
    standardOutput = stdout
  }
  String resultString = stdout.toString()
  return resultString.isEmpty() ? null : new File(resultString)
}

/*
 * Get a property value by name searching project properties, system properties
 * and environment variables.
 *
 * @param propertyName Name of the property to search for.
 * @param defaultValue Value of the property if it's not found.
 *
 * @returns Property value as string if found and not empty, null otherwise.
 */
String findProperty(String propertyName, String defaultValue = null) {
  Closure valueIsSet = {
    valueString -> valueString != null && !valueString.isEmpty()
  }
  String value = null
  for (def queryObject in [project, System]) {
    if (queryObject.hasProperty(propertyName)) {
      value = queryObject.getProperty(propertyName)
      if (valueIsSet(value)) {
        return value
      }
    }
  }
  value = System.getenv(propertyName)
  return valueIsSet(value) ? value : defaultValue
}

/*
 * Get a property value by name as a file, searching project properties,
 * system properties and environment variables.
 *
 * @param propertyName Name of the property to search for.
 * @param defaultValue Value of the property if it's not found.
 * @param mustExist Whether the file must exist.
 *
 * @returns Property value as a File if found and exists (if mustExist is true),
 *  null otherwise.
 */
File findFileProperty(String propertyName, File defaultValue = null,
                      Boolean mustExist = false) {
  String foundFilePath = findProperty(
    propertyName, defaultValue != null ? defaultValue.absolutePath : null)
  File foundFile = foundFilePath != null ? new File(foundFilePath) : null
  return foundFile != null && (!mustExist || foundFile.exists()) ?
    foundFile : null
}

/*
 * Get a File from the specified property or the shortest path in the specified
 * FileTree object.
 *
 * @param propertyName Property name to lookup prior to searching the tree
 *   for a matching file.
 * @param useParentDirectory If set to true, this returns a File object pointing
 *   at the parent directory of the file that is found.
 * @param fileTreeClosure Closure which returns a FileTree object to search.
 *
 * @return File if it's found and exists, null otherwise.
 */
File getFileFromPropertyOrFileTree(String propertyName,
                                   Boolean useParentDirectory,
                                   fileTreeClosure) {
  File fileValue = findFileProperty(propertyName, null, true)
  if (fileValue == null) {
    // Search for the shortest path to the require file.
    fileTreeClosure().files.each { currentFile ->
      if (fileValue == null ||
          fileValue.absolutePath.length() > currentFile.absolutePath.length()) {
        fileValue = currentFile
      }
    }
    if (useParentDirectory && fileValue != null) {
      fileValue = fileValue.parentFile
    }
  }
  return fileValue
}

/*
 * Set a project property and log it.
 *
 * @param name Name of the property.
 * @param value Value of the property.
 * @param properties Map of properties to save to.
 */
void saveProperty(String name, value, Properties properties) {
  if (value != null) properties.setProperty(name.toString(), value.toString())
  logger.info(sprintf("%s: %s", name, value))
}

/*
 * Make sure the NUnit DLL property is set.
 */
void checkNUnitDllPath() {
  if (project.ext.unityNUnitDll == null) {
    throw new StopActionException("NUnit DLL not found.")
  }
}

/*
 * Make sure the NUnit console property is set.
 */
void checkNUnitConsolePath() {
  if (project.ext.nunitConsoleExe == null) {
    throw new StopActionException("NUnit Console not found.")
  }
}

/*
 * Removes the extension from a filename.
 *
 * @param fileObj File object to split into a basename and extension.
 *
 * @returns (basename, extension) tuple where basename is the filename without
 * an extension and extension is the extension.
 */
List<String> splitFilenameExtension(File fileObj) {
  String filename = fileObj.name
  String trimmedFilename = filename
  if (trimmedFilename.endsWith(project.ext.unityMetadataExtension)) {
    trimmedFilename -= project.ext.unityMetadataExtension
  }
  if (trimmedFilename.endsWith(".dll.mdb")) {
    trimmedFilename -= ".mdb"
  }
  int extensionIndex = trimmedFilename.lastIndexOf(".")
  if (extensionIndex < 0) return [filename, ""]
  String basename = filename.substring(0, extensionIndex)
  String extension = filename.substring(extensionIndex)
  return [basename, extension]
}

/*
 * Construct the name of a versioned asset from the source filename and version
 * string.  If fullVersionPrefix is true, the encoded string takes the form
 * ${filename}_version-${version}.${extension}
 * if fullVersionPrefix is false, the string takes the form
 * ${filename}_v${version}.${extension}
 * where extension is derived from the specified filename.
 *
 * @param fileObj File to add version to.
 * @param fullVersionPrefix if true uses the "_version-" otherwise uses "_v-".
 * @param postfix Optional string to add before the extensioon.
 * @param useVersionDir If true, place the file to be under a folder named after
 *        the version number, instead of changing the filename.
 *
 * @returns File which includes an encoded version.
 */
File versionedAssetFile(File fileObj, Boolean fullVersionPrefix,
                        String postfix, Boolean useVersionDir) {
  String basename
  String extension
  (basename, extension) = splitFilenameExtension(fileObj)
  // Encode the DLL version and target names into the DLL in the form...
  // ${dllname}_version-${version}.dll
  String targetName = basename
  String version = project.ext.pluginVersion
  File dllDir = fileObj.parent != null ? new File(fileObj.parent) :
        new File()
  if (!(version == null || version.isEmpty())) {
    if (useVersionDir) {
      dllDir = new File(dllDir, version)
    } else {
      targetName += (fullVersionPrefix ? "_version-" : "_v") + version
    }
  }
  String filename = targetName + postfix + extension
  return new File(dllDir, filename)
}

/*
 * Remove the version component from a path. (Both its filename and its parent
 * folder)
 *
 * @param fileObj File to remove version from.
 *
 * @returns File with removed version string.
 */
File unversionedAssetFile(File fileObj) {
  // Remove the version postfix. Ex.
  // "ExternalDependencyManager/Editor/Google.IOSResolver_v1.2.166.dll" ->
  // "ExternalDependencyManager/Editor/Google.IOSResolver.dll"
  String basename
  String extension
  (basename, extension) = splitFilenameExtension(fileObj)
  def versionRegExFull = /^(.*)_(version-[^-]+)$/
  def versionRegExShort = /^(.*)_(v[^v]+)$/
  def versionMatch = basename =~ versionRegExShort
  if (versionMatch.matches()) {
    basename = versionMatch.group(1)
  } else {
    versionMatch = basename =~ versionRegExFull
    if (versionMatch.matches()) {
      basename = versionMatch.group(1)
    }
  }
  String filename = basename + extension

  // Remove the version folder as well. Ex.
  // "ExternalDependencyManager/Editor/1.2.166/Google.IOSResolver.dll" ->
  // "ExternalDependencyManager/Editor/Google.IOSResolver.dll"
  def versionFolderRegEx = /^[0-9]+\.[0-9]+\.[0-9]+$/
  File parent = fileObj.parent != null ? new File(fileObj.parent) : null
  if (parent != null) {
      String parentFolder = parent.name
      def folderMatch = parentFolder =~ versionFolderRegEx
      if (folderMatch.matches()) {
          parent = parent.parent != null ? new File(parent.parent) : null
      }
  }
  return parent != null ? new File(parent, filename) : new File(filename)
}

/*
 * Copy a file.
 *
 * @param sourceFile File to copy.
 * @param targetFile File to write to.
 *
 * @returns targetFile.
 */
File copyFile(File sourceFile, File targetFile) {
  targetFile.parentFile.mkdirs()
  logger.info(sprintf("Copy %s -> %s", sourceFile.path, targetFile.path))
  targetFile.newOutputStream() << sourceFile.newInputStream()
  return targetFile
}

/*
 * Copy a list of files from one directory into another.
 *
 * @param taskName Name of the task.
 * @param taskDescription Description of the task.
 * @param filesToCopy List of files to copy with paths relative to the source
 * directory.
 * @param sourceDir Directory to copy files from.
 * @param targetDir Directory to copy files into preserving the relative path of
 * each file.
 * @param dependsOn List of dependencies for the task.
 * @param copyFileClosure Closure which takes (sourceFile, targetFile) to copy a
 * file.
 *
 * @returns Task which copies the specified files.  The ext.sourceTargetFileMap
 * property of the task contains the mapping of source to target files to be
 * copied by the task.
 */
Task createCopyFilesTask(String taskName, String taskDescription,
                         Iterable<File> filesToCopy, File sourceDir,
                         File targetDir, Iterable<Task> dependsOn,
                         Closure copyFileClosure) {
  Map<File, File> sourceTargetFileMap = filesToCopy.collectEntries {
    [(new File(sourceDir, it.path)), (new File(targetDir, it.path))]
  }
  if (!copyFileClosure) {
    copyFileClosure = {
      sourceFile, targetFile -> copyFile(sourceFile, targetFile)
    }
  }
  Task copyTask = tasks.create(name: taskName,
                               description: taskDescription,
                               type: Task,
                               dependsOn: dependsOn).with {
    inputs.files sourceTargetFileMap.keySet()
    outputs.files sourceTargetFileMap.values()
    doLast {
      sourceTargetFileMap.each { sourceFile, targetFile ->
        copyFileClosure(sourceFile, targetFile)
      }
    }
  }
  copyTask.ext.sourceTargetFileMap = sourceTargetFileMap
  return copyTask
}

/*
 * Copy a file, injecting release information if it's a Unity asset metadata
 * file.
 *
 * @param sourceFile File to copy from.
 * @param targetFile File to copy to.
 *
 * @return targetFile.
 */
File copyAssetMetadataFile(File sourceFile, File targetFile) {
  if (!sourceFile.name.endsWith(project.ext.unityMetadataExtension)) {
    return copyFile(sourceFile, targetFile)
  }
  String[] lines = sourceFile.text.tokenize("\n")

  // Parse the existing version from the asset metadata.
  def folderAssetRegEx = /^folderAsset:\s+yes\s*$/
  def versionRegEx = /^(-\s+gvh_version-)([a-zA-Z0-9.]+)\s*$/
  def exportPathRegEx = /^(-\s+gvhp_exportpath-)(.*)$/
  Boolean isFolder = false
  String currentVersion = ""
  lines.each { String line ->
    def versionMatch = line =~ versionRegEx
    def folderMatch = line =~ folderAssetRegEx
    if (versionMatch.matches()) {
      currentVersion = versionMatch.group(2)
    } else if (folderMatch.matches()) {
      isFolder = true
    }
  }
  Boolean isNotVersioned = (isFolder ||
                            targetFile.name.startsWith(
                                "play-services-resolver"))
  // Ignore folder assets, they don't need to be versioned.
  if (isNotVersioned) return copyFile(sourceFile, targetFile)
  Boolean versionChanged = currentVersion != project.ext.pluginVersion

  List<String> outputLines = []
  lines.each { line ->
    if (versionChanged) {
      def guidMatch = (line =~ /^(guid:)\s+(.*)/)
      def versionLabelMatch = (line =~ versionRegEx)
      def exportPathMatch = (line =~ exportPathRegEx)
      if (guidMatch.matches() && (sourceFile.name != targetFile.name ||
            sourceFile.parent != targetFile.parent ) ) {
        // Update the metadata's GUID.
        // If a file is renamed we want to make sure Unity imports it as a new
        // asset with the new filename.
        line = sprintf(
          "%s %s",
          guidMatch.group(1),
          java.util.UUID.randomUUID().toString().replace("-", ""))
      } else if (versionLabelMatch.matches()) {
        // Update the version metadata for the asset.
        line = sprintf("%s%s", versionLabelMatch.group(1),
                       project.ext.pluginVersion)
      } else if (exportPathMatch.matches()) {
        // Update the export path of the asset.
        line = sprintf("%s%s", exportPathMatch.group(1),
                       targetFile.path.replaceFirst(/.*\/Assets\//, ""))
        line = line.substring(0, line.length() -
                              project.ext.unityMetadataExtension.length())
      }
    }
    outputLines.add(line)
    // If the metadata file does not contain a version label, inject it.
    if (currentVersion.isEmpty() && line.startsWith("labels:")) {
      outputLines.add(sprintf("- gvh_version-%s", project.ext.pluginVersion))
    }
  }
  targetFile.write(outputLines.join("\n") + "\n")

  return targetFile
}

/*
 * Build a project with xbuild.
 *
 * @param taskName Name of the task.
 * @param taskDescription Description of the task.
 * @param projectToBuild Path to the project to build.
 * @param target Target to build in the project.
 * @param inputFiles Input files for the project.
 * @param outputDir Output directory.
 * @param outputFiles List of output file paths relative to the output
 * directory.
 * @param dependsOn List of dependencies for the task.
 *
 * @returns Task which builds the specified target.
 */
Task createXbuildTask(String taskName, String taskDescription,
                      File projectToBuild, String target,
                      Iterable<File> inputFiles, File outputDir,
                      Iterable<File> outputFiles, Iterable<Task> dependsOn) {
  File intermediatesDir = new File(outputDir, "obj")
  File binaryOutputDir = new File(outputDir, "bin")
  Iterable<File> outputFilesInBinaryOutputDir = outputFiles.collect {
    return new File(binaryOutputDir, it.path)
  }

  if (project.ext.debugEnabled) {
    outputFilesInBinaryOutputDir += outputFilesInBinaryOutputDir.findResults {
      return it.name.endsWith(".dll") ?
        new File(it.parentFile.path,
                 splitFilenameExtension(it)[0] +
                 project.ext.symbolDatabaseExtension) : null
    }
  }

  Iterable<Task> dependsOnTasks = dependsOn ? dependsOn : []
  Iterable<Task> compileTaskDependencies = dependsOnTasks.clone()
  Iterable<Task> patchVersionFilesTasks = inputFiles.findResults {
    if (it.name == "VersionNumber.cs") {
      File versionFile = it
      Task patchVersionTask = tasks.create(
        name: taskName + "AddVersionTo" + it.name,
        description: "Add version to " + it.path,
        type: Task,
        dependsOn: dependsOnTasks)
      patchVersionTask.with {
        inputs.files files([versionFile])
        outputs.files files([versionFile])
        doLast {
          String[] lines = versionFile.text.split("\n")
          List<String> outputLines = lines.collect {
            it.replaceAll(
              /(^.*VERSION_STRING[ ]*=[ ]*\")([^\"]+)(\".*)/,
              '$1' + project.ext.pluginVersion + '$3')
          }
          String patchedFileString = (outputLines.join("\n") + "\n")
          if (versionFile.text != patchedFileString) {
            print("Patch " + versionFile.name)
            versionFile.write(patchedFileString)
          }
        }
      }
      return patchVersionTask
    }
  }
  if (patchVersionFilesTasks) {
    compileTaskDependencies += patchVersionFilesTasks
  }

  Task task = tasks.create(name: taskName,
                           description: taskDescription,
                           type: Task,
                           dependsOn: compileTaskDependencies).with {
    inputs.files inputFiles
    outputs.files files(outputFilesInBinaryOutputDir)
    doLast {
      exec {
        executable project.ext.xbuildExe
        workingDir projectToBuild.parentFile.absolutePath
        args ([sprintf("/target:%s", target),
               sprintf("/property:UnityHintPath=%s",
                       project.ext.unityDllPath.absolutePath),
               sprintf("/property:UnityIosPath=%s",
                       project.ext.unityIosPath.absolutePath),
               sprintf("/property:NUnityHintPath=%s",
                       project.ext.unityNUnitDll ?
                 project.ext.unityNUnitDll.absolutePath: ""),
               sprintf("/property:BaseIntermediateOutputPath=%s%s",
                       intermediatesDir.absolutePath,
                       File.separator),
               sprintf("/property:OutputPath=%s%s",
                       binaryOutputDir.absolutePath,
                       File.separator),
               "/verbosity:quiet",
               projectToBuild.absolutePath])
      }
    }
  }
  task.ext.buildDir = outputDir
  return task
}

/*
 * Generates tasks to compile a plugin DLL and copy it to plugin staging
 * area directory.
 *
 * @param componentName Basename of the generated tasks.
 * @param projectName Name of the project under
 * source/${projectName}/${projectName}.csproj to build.
 * @param assemblyDllBasename Basename of the output DLL generated from the
 * specified project.
 * @param versionDll Whether the output DLL filename should contain the plugin
 * version.
 * @param dependsOn List of tasks that should be completed before this plugin
 * task is executed.
 *
 * @returns Task that builds the DLL to the build output folder.
 */
Task createBuildPluginDllTask(String componentName,
                              String projectName,
                              String assemblyDllBasename,
                              Boolean versionDll,
                              Iterable<Task> dependsOn = null) {
  File projectDir = new File(project.ext.pluginSourceDir, projectName)
  File projectBuildDir = new File(project.ext.buildDir, projectName)

  // Compile the C# project.
  Task compileTask = createXbuildTask(
    sprintf("compile%s", componentName), sprintf("Compile %s", projectName),
    project.ext.pluginSolutionFile, projectName,
    fileTree(new File(projectDir, "src")), projectBuildDir,
    [new File(assemblyDllBasename)], dependsOn)
  compileTask.ext.componentName = componentName

  // Template metadata for the built DLL.
  Iterable<File> assemblyDllMetaFiles =
    compileTask.outputs.files.collect {
      new File(new File(project.ext.pluginTemplateDir,
                        project.ext.pluginEditorDllDir.path),
               it.name + project.ext.unityMetadataExtension)
    }
  // Optionally map unversioned to versioned filenames.
  Iterable<File> unversionedFiles = files(compileTask.outputs.files,
                                          assemblyDllMetaFiles)

  File stagingDir = new File(new File(projectBuildDir,
                                      project.ext.pluginStagingAreaDir.name),
                             project.ext.pluginEditorDllDir.path)
  Map<String, File> stagingFileMap =
    unversionedFiles.collectEntries { File unversionedFile ->
      File unversionedOutputFile = new File(stagingDir.path,
                                            unversionedFile.name)
      return [
        unversionedFile.path,
        versionDll ?
          versionedAssetFile(unversionedOutputFile, false, "", true) :
          unversionedOutputFile]
    }

  // Copy files to the staging directory for this project.
  Task copyTask = tasks.create(
      name: sprintf("copy%sStaging", componentName),
      type: Task,
      description: sprintf("Copy %s DLLs to the plugin staging dir.",
                         projectName),
      dependsOn: [compileTask]).with {
    inputs.files unversionedFiles
    outputs.files stagingFileMap.values()
    doLast {
      inputs.files.each {
        File inputFile ->
          copyAssetMetadataFile(inputFile, stagingFileMap[inputFile.path])
      }
    }
  }
  copyTask.ext.stagingDir = stagingDir
  copyTask.ext.componentName = componentName

  // Generate a clean target for this project.
  Task cleanTask = tasks.create(name: sprintf("clean%s", componentName),
               description: sprintf("Clean %s plugin DLL", projectName),
               type: Delete).with {
    delete (files(compileTask.outputs.files,
                  copyTask.outputs.files,
                  projectBuildDir))
  }
  cleanTask.ext.componentName = componentName

  // Return the build target for this project.
  Task buildTask =
    tasks.create(name: sprintf("build%s", componentName),
                 description: sprintf("Build %s plugin DLL",
                                      projectName),
                 dependsOn: [copyTask])
  buildTask.ext.componentName = componentName
  return buildTask
}

/*
 * Create a Nunit test task.
 *
 * @param name Name of the task.
 * @param description Description of the task.
 * @param testDll Test DLL to execute.  The log file will be placed in the
 * parent directory of this DLL path.
 * @param dependsOn Dependencies of the new task.
 *
 * @returns Task which executes nunit-console.
 */
Task createNUnitTask(String name, String description, File testDll,
                     Iterable<Task> dependsOn) {
  File logFileDir = testDll.parentFile.parentFile
  File logFile = new File(logFileDir, name + ".log")
  File xmlLogFile = new File(logFileDir, name + ".xml")
  return tasks.create(name: name,
                      description: description,
                      type: Task,
                      dependsOn: dependsOn).with {
    inputs.files testDll
    outputs.files logFile
    doFirst { checkNUnitConsolePath() }
    doLast {
      exec {
        workingDir project.ext.pluginSourceDir
        executable project.ext.nunitConsoleExe
        args ([sprintf("-output:%s", logFile.absolutePath),
               sprintf("-xml:%s", xmlLogFile.absolutePath),
               testDll.absolutePath])
      }
    }
  }
}

/*
 * Create a task to run an executable.
 *
 * @param name Name of the task.
 * @param description Description of the task.
 * @param dependsOn Tasks this depends upon.
 * @param executable Executable to run.
 * @param arguments Arguments for the executable.
 *
 * @returns Task which runs the specified executable.
 */
Task createExecTask(String name, String description,
                    Iterable<Task> dependsOn, File executableToRun,
                    Iterable<String> arguments) {
  Task execTask = tasks.create(name: name,
                               description: description,
                               type: Exec,
                               dependsOn: dependsOn)
  execTask.with {
    executable executableToRun
    args arguments
  }
  return execTask
}

/*
 * Create a task that does nothing.
 *
 * @param taskName Name of the task to create.
 * @param summary Description of the task.
 * @param dependsOn Dependencies of the new task.
 *
 * @returns Task that does nothing.
 */
Task createEmptyTask(String taskName, String summary,
                     Iterable<Task> dependsOn) {
  Task emptyTask = tasks.create(name: taskName,
                                description: sprintf("(disabled) %s", summary),
                                dependsOn: dependsOn)
  emptyTask.with {
    doLast {
      logger.info(sprintf("%s disabled", taskName))
    }
  }
  return emptyTask
}

/*
 * Create a task to execute Unity.
 *
 * @param taskName Name of the task to create.
 * @param summary Description of the operation being performed with Unity.
 * "create" is a reserved operation that creates a project.  This is used to
 * generate the log file name so should be unique for the project and ideally
 * not contain whitespace.
 * @param dependsOn Dependencies of the new task.
 * @param projectName Name of the project directory to use.
 * @param projectContainerDir Directory that contains the project directory.
 * @param arguments Command line arguments to pass to Unity.
 * @param batchMode Whether to run Unity in batch mode.
 * @param createTaskClosure Optional task used to start Unity, this must
 *   conform to createExecTask()
 *
 * @returns Task which executes Unity.
 * The following extended properties are set on the task:
 * - ext.projectDir: Directory of the created Unity project.
 * - ext.containerDir: Directory which contains the Unity project and the logs.
 *   This is the same as projectContainerDir.
 * - ext.logFile: Unity log file from the operation.
 */
Task createUnityTask(String taskName, String summary,
                     Iterable<Task> dependsOn, String projectName,
                     File projectContainerDir, Iterable<String> arguments,
                     Boolean batchMode, createTaskClosure) {
  Boolean createProject = summary == "create"
  File logFile = new File(projectContainerDir,
                          sprintf("%s_%s.log", projectName, summary))
  File projectDir = new File(projectContainerDir, projectName)
  List<String> executeArguments = []

  if (batchMode) {
    executeArguments += project.ext.unityBatchModeArguments
  } else {
    executeArguments += project.ext.unityInteractiveModeArguments
  }
  executeArguments += [
    "-logFile", logFile.absolutePath,
    createProject ? "-createProject" : "-projectPath", projectDir.absolutePath]
  if (createProject) executeArguments += ["-quit"]
  executeArguments += arguments

  if (!createTaskClosure) {
    createTaskClosure = {
      String name, String description, Iterable<Task> depends,
      File executable, Iterable<String> args ->
        return createExecTask(name, description, depends, executable, args)
    }
  }

  Task unityTask
  if (!batchMode && !project.ext.interactiveModeTestsEnabled) {
    unityTask = createEmptyTask(taskName, summary, dependsOn)
  } else {
    unityTask = createTaskClosure(taskName,
                                  sprintf(
                                    "Run Unity to %s (project: %s)",
                                    summary, projectName),
                                  dependsOn,
                                  project.ext.unityExe,
                                  executeArguments)
  }
  unityTask.with {
    outputs.files files(logFile)
  }
  unityTask.ext.projectDir = projectDir
  unityTask.ext.containerDir = projectContainerDir
  unityTask.ext.logFile = logFile
  return unityTask
}

/*
 * Create a task that generates a Unity project.
 *
 * @param taskName Name of the task.
 * @param dependsOn Dependencies of the new task.
 * @param projectName Name of the project directory to create.
 * @param projectContainerDir Directory to create the project directory in.
 *
 * @returns Task which executes Unity.
 * The following extended properties are set on the task:
 * - ext.projectDir: Directory of the created Unity project.
 * - ext.containerDir: Directory which contains the Unity project and the logs.
 *   This is the same as projectContainerDir.
 * - ext.logFile: Unity log file from the operation.
 */
Task createUnityProjectTask(String taskName, Iterable<Task> dependsOn,
                            String projectName, File projectContainerDir) {
  return createUnityTask(taskName, "create", dependsOn, projectName,
                         projectContainerDir, [], true, null).with {
    doFirst {
      // Clean / create the output directory.
      delete ext.containerDir
      ext.containerDir.mkdirs()
    }
  }
}

/*
 * Setup a Unity project for a testing task and import the plugin in
 * preparation for testing.
 *
 * @param taskName Name of the test task.
 * @param dependsOn Dependencies of the new task.
 * @param projectName Name of the Unity project to create.
 * @param batchMode Whether to run Unity in batch mode.
 *
 * @returns Task which sets up a Unity project.
 * The following extended properties are set on the task:
 * - ext.projectDir: Directory of the created Unity project.
 * - ext.containerDir: Directory which contains the Unity project and the logs.
 * - ext.logFile: Unity log file for the import operation.
 */
Task createSetupUnityProjectTask(String taskName, Iterable<Task> dependsOn,
                                 String projectName, Boolean batchMode) {
  File outputDir = new File(project.ext.testDir, projectName)
  Task createProject = createUnityProjectTask(
      sprintf("create%s", taskName), dependsOn, projectName, outputDir)
  createProject.with {
    inputs.files files(project.ext.pluginExportFile)
  }
  return createUnityTask(
      taskName, "import_plugin", [createProject], projectName, outputDir,
      ["-importPackage", project.ext.pluginExportFile.absolutePath,
       "-quit"], batchMode, null)
}

/*
 * Creates a task which runs a test with the Unity plugin.
 *
 * @param taskName Name of the test.
 * @param description Description of the task.
 * @param dependsOn Dependencies of the new task.
 * @param testScriptsDir Directory containing scripts to copy into the test
 *   project and execute for testing.
 * @param additionalArguments Additional arguments to pass to Unity when
 *   executing the test.
 * @param batchMode Whether to execute Unity in batch mode.
 * @param editorAssets Files to copy into the Assets/Editor folder in the
 *   project.
 * @param createTaskClosure Optional task used to start Unity, this must
 *   conform to tasks.create(name, description, type, dependsOn).
 *
 * @returns Test task.
 */
Task createUnityTestTask(String taskName, String description,
                         Iterable<Task> dependsOn, File testScriptsDir,
                         Iterable<File> editorAssets,
                         Iterable<String> additionalArguments,
                         Boolean batchMode, createTaskClosure) {
  List<File> testScripts = []
  if (testScriptsDir) {
    testScripts = fileTree(testScriptsDir).collect {
      new File(it.absolutePath.substring(
                 testScriptsDir.absolutePath.length() + 1))
    }
  }

  // Setup the Unity project.
  Task setupTestProject = createSetupUnityProjectTask(
    sprintf("setup%s", taskName), dependsOn, taskName, batchMode)
  setupTestProject.with {
    inputs.files (testScripts + editorAssets)
  }

  List<Task> copyTasks = []

  // Task which copies test scripts into the project.
  if (testScriptsDir) {
    Task copyTestScripts = createCopyFilesTask(
      sprintf("copyScriptsFor%s", taskName),
      sprintf("Copy the test scripts into the %s Unity project.", taskName),
      testScripts, testScriptsDir, setupTestProject.ext.projectDir,
      [setupTestProject], null)
    copyTasks += [copyTestScripts]
  }

  // Task which copies editor scripts into the project.
  Task copyEditorAssets = tasks.create(
    name: sprintf("copyEditorAssetsFor%s", taskName),
    description: sprintf("Copy the editor assets into the %s Unity project.",
                         taskName),
    type: Copy,
    dependsOn: [setupTestProject])
  copyEditorAssets.with {
    from editorAssets
    into new File(new File(setupTestProject.ext.projectDir, "Assets"),
                  "Editor")
  }
  copyTasks += [copyEditorAssets]

  // Create the test task.
  Task testTask = createUnityTask(taskName, "test",
                                  copyTasks,
                                  setupTestProject.ext.projectDir.name,
                                  setupTestProject.ext.containerDir,
                                  additionalArguments, batchMode,
                                  createTaskClosure)
  testTask.description = description

  // Create a clean task
  Task cleanTestTask = tasks.create(name: sprintf("clean%s", taskName),
                                    description: sprintf("Clean %s", taskName),
                                    type: Delete).with {
    delete setupTestProject.ext.containerDir
  }

  return testTask
}

/*
 * Creates a task which runs tests with the Unity plugin in batch and
 * non-batch modes.
 *
 * @param taskName Name of the test.
 * @param description Description of the task.
 * @param dependsOn Dependencies of the new task.
 * @param testScriptsDir Directory containing scripts to copy into the test
 *   project and execute for testing.
 * @param editorAssets Files to copy into the Assets/Editor folder in the
 *   project.
 * @param additionalArguments Additional arguments to pass to Unity.
 * @param createTaskClosure Optional task used to start Unity, this must
 *   conform to tasks.create(name, description, type, dependsOn).
 *
 * @returns Test task.
 */
Task createUnityTestBatchAndNonBatch(String taskName, String description,
                                     Iterable<Task> dependsOn,
                                     File testScriptsDir,
                                     Iterable<File> editorAssets,
                                     Iterable<String> additionalArguments,
                                     createTaskClosure) {
  return tasks.create(name: taskName,
                      description: description,
                      dependsOn: [
                        createUnityTestTask(
                          sprintf("%sBatchMode", taskName),
                          sprintf("%s (Batch Mode)", description),
                          dependsOn, testScriptsDir, editorAssets,
                          additionalArguments, true, createTaskClosure),
                        createUnityTestTask(
                          sprintf("%sInteractiveMode", taskName),
                          sprintf("%s (Interactive Mode)", description),
                          dependsOn, testScriptsDir, editorAssets,
                          additionalArguments, false, createTaskClosure)])
}

Task compileResolverLibTests = createXbuildTask(
    "compileResolverLibTests",
    "Compile tests for the deprecated Jar Resolver library.",
    project.ext.pluginSolutionFile, "JarResolverTests",
    fileTree(new File(new File(project.ext.pluginSourceDir,
                               "JarResolverLib"), "src")),
    new File(project.ext.testDir, "ResolverLibTests"),
    [new File("JarResolverTests.dll")], []).with {
  doFirst { checkNUnitDllPath() }
}

/*
 * Install Python packages.
 *
 * @param taskName Name of the task to create.
 * @param description Description of the task.
 * @param dependsOn Dependencies of the new task.
 * @param packages Packages to install.
 *
 * @returns Task which executes pip to install packages
 */
Task createInstallPythonPackageTask(String taskName, String description,
                                    Iterable<Task> dependsOn,
                                    Iterable<String> packages) {
  Task installPythonPackageTask = tasks.create(
      name: taskName,
      description: sprintf("Run Pip to %s", description),
      type: Exec,
      dependsOn: dependsOn + ["build_envs"]).with {
    executable project.ext.pipExe
    args (["-q", "install"] + packages)
  }
}

/*
 * Create a task to execute Python.
 *
 * @param taskName Name of the task to create.
 * @param description Description of the task.
 * @param dependsOn Dependencies of the new task.
 * @param script Python script to run.
 * @param arguments Command line arguments to pass to the Python script.
 * @param packages Optional Python packages to install.
 *
 * @returns Task which executes Python.
 */
Task createPythonTask(String taskName, String description,
                      Iterable<Task> dependsOn,
                      File script, Iterable<String> arguments,
                      Iterable<String> packages) {
  List<Task> installPackagesTask = []
  if (packages) {
    installPackagesTask = [
      createInstallPythonPackageTask(
        taskName + "InstallPipPackages",
        sprintf("install packages %s for %s", packages.toString(), taskName),
        [],
        packages)
    ]
  }
  Task pythonTask = tasks.create(
      name: taskName,
      description: sprintf("Run Python to %s", description),
      type: Exec,
      dependsOn: (dependsOn + installPackagesTask + ["build_envs"])).with {
    executable project.ext.pythonExe
    args ([script.absolutePath] + arguments)
  }
  return pythonTask
}

/*
 * Creates a task that packages a Unity plugin with export_unity_package.py.
 *
 * @param taskName Name of the task to create.
 * @param description Description of the task.
 * @param dependsOn Dependencies of the new task.
 * @param configFile Configuration file which specifies input files.
 * @param guidsFile Optional GUIDs database file.
 * @param assetsDir Input directory for assets referenced by the configFile.
 * @param generateUnitypackage Whether to create a .unitypackage.
 * @param generateUpmTarball Whether to create a UPM tarball.
 * @param pluginsVersion Version to apply to exported plugins.
 * @param outputDir Directory to write the the exported archives.
 * @param arguments Additional arguments for export_unity_package.py
 */
Task createExportUnityPackageTask(String taskName,
                                  String description,
                                  Iterable<Task> dependsOn,
                                  File configFile,
                                  File guidsFile,
                                  File assetsDir,
                                  Boolean generateUnityPackage,
                                  Boolean generateUpmTarball,
                                  String pluginVersion,
                                  File outputDir,
                                  Iterable<String> arguments) {
  File exportScript = new File(project.ext.exportUnityPackageDir,
                               "export_unity_package.py")
  Task exportUnityPackageTask = createPythonTask(
    taskName,
    description,
    dependsOn,
    exportScript,
    ["--config_file", configFile,
     "--assets_dir", assetsDir,
     "--plugins_version", pluginVersion,
     "--output_dir", outputDir] +
    [generateUnityPackage ?
      "--output_unitypackage" : "--nooutput_unitypackage"] +
    [generateUpmTarball ? "--output_upm" : "--nooutput_upm"] +
    (guidsFile ? ["--guids_file", guidsFile] : []) +
    ["-v", "-1"] + // Only display warnings.
    arguments,
    exportUnityPackageRequirements)
  exportUnityPackageTask.with {
    inputs.files ([configFile] +
                  (guidsFile ? [guidsFile] : []) +
                  fileTree(assetsDir) +
                  [exportScript])
  }
  return exportUnityPackageTask
}

Task createGenGuidTask(String taskName,
                       String description,
                       File guidsFile,
                       String pluginVersion,
                       Iterable<String> guidPath) {
  File genGuidScript = new File(project.ext.exportUnityPackageDir,
                               "gen_guids.py")
  Task genGuidTask = createPythonTask(
    taskName,
    description,
    [],
    genGuidScript,
    ["--version", pluginVersion,
     "--guids_file", guidsFile] +
    guidPath,
    genGuidRequirements)
  genGuidTask.with {
    inputs.files ([guidsFile] +
                  [genGuidScript])
  }
  return genGuidTask
}


Task testResolverLibTests = createNUnitTask(
  "testResolverLibTests",
  "Runs the tests for the deprecated Jar Resolver library",
  compileResolverLibTests.outputs.files[0],
  [compileResolverLibTests])

task cleanResolverLibTests() {
  description "Clean test output for the deprecated Jar Resolver library"
  doLast { delete files(compileResolverLibTests.ext.buildDir,
                        testResolverLibTests.outputs.files) }
}

task testDownloadArtifacts(type: GradleBuild) {
  description "Run tests for the download_artifacts.gradle script."
  dir "source/AndroidResolver/scripts"
}

createPythonTask(
  "testPackageUploader",
  "Test the unity_asset_uploader.py application.",
  [],
  new File(project.ext.unityAssetUploaderDir, "unity_asset_uploader_test.py"),
  [],
  [])

createPythonTask(
  "testExportUnityPackage",
  "Test the export_unity_package.py application",
  [],
  new File(project.ext.exportUnityPackageDir, "export_unity_package_test.py"),
  [],
  exportUnityPackageRequirements)

createPythonTask(
  "testGenGuids",
  "Test the gen_guids.py application",
  [],
  new File(project.ext.exportUnityPackageDir, "gen_guids_test.py"),
  [],
  ["absl-py"])

createPythonTask(
  "testImportUnityPackage",
  "Test the import_unity_package.py application",
  [],
  new File(project.ext.importUnityPackageDir, "import_unity_package_test.py"),
  [],
  ["absl-py"])

task updateEmbeddedGradleWrapper(type: Zip) {
  description "Update the gradle wrapper in gradle-template.zip"
  from project.ext.scriptDirectory
  include "gradlew"
  include "gradlew.bat"
  include "gradle/**"
  archiveName "gradle-template.zip"
  destinationDir (new File(project.ext.scriptDirectory,
                           "source/AndroidResolver/scripts"))
}

Task buildVersionHandler = createBuildPluginDllTask(
  "VersionHandler", "VersionHandler", "Google.VersionHandler.dll", false)
Task buildVersionHandlerImpl = createBuildPluginDllTask(
  "VersionHandlerImpl", "VersionHandlerImpl", "Google.VersionHandlerImpl.dll",
  true, [buildVersionHandler])
Task buildAndroidResolver = createBuildPluginDllTask(
  "AndroidResolver", "AndroidResolver", "Google.JarResolver.dll", true,
  [updateEmbeddedGradleWrapper, buildVersionHandlerImpl])
Task buildIosResolver = createBuildPluginDllTask(
  "IosResolver", "IOSResolver", "Google.IOSResolver.dll", true,
  [buildAndroidResolver])
Task buildPackageManagerResolver = createBuildPluginDllTask(
  "PackageManagerResolver", "PackageManagerResolver",
  "Google.PackageManagerResolver.dll", true,
  [buildVersionHandlerImpl])

task preparePluginStagingAreaDir(type: Task) {
  description "Delete all files that should not be present in staging area."
  doLast {
    Set<String> excludePaths = (
      files(
        copyPluginTemplateToStagingArea.outputs.files,
        copyPluginComponentsToStagingArea.outputs.files,
        generatePluginManifest.outputs.files).files.collect {
        it.absolutePath
      }).toSet()
    fileTree(project.ext.pluginStagingAreaDir).each { fileObj ->
      if (!excludePaths.contains(fileObj.absolutePath)) {
        delete fileObj
      }
    }
  }
}

Task copyPluginTemplateToStagingArea = createCopyFilesTask(
  "copyPluginTemplateToStagingArea",
  "Copy the template project into the Unity plugin packaging dir.",
  [new File("Assets", "ExternalDependencyManager.meta"),
   new File(new File("Assets", "ExternalDependencyManager"), "Editor.meta"),
   new File(new File(new File("Assets", "ExternalDependencyManager"), "Editor"),
            "CHANGELOG.md.meta"),
   new File(new File(new File("Assets", "ExternalDependencyManager"), "Editor"),
            "LICENSE.meta"),
   new File(new File(new File("Assets", "ExternalDependencyManager"), "Editor"),
            "README.md.meta"),
   new File("Assets", "PlayServicesResolver.meta"),
   new File(new File("Assets", "PlayServicesResolver"), "Editor.meta"),
   new File(new File(new File("Assets", "PlayServicesResolver"), "Editor"),
            "play-services-resolver_v1.2.137.0.txt"),
   new File(new File(new File("Assets", "PlayServicesResolver"), "Editor"),
            "play-services-resolver_v1.2.137.0.txt.meta")],
  project.ext.pluginTemplateDir, project.ext.pluginStagingAreaDir,
  [preparePluginStagingAreaDir],
  { sourceFile, targetFile -> copyAssetMetadataFile(sourceFile, targetFile) })

Task copyDocumentationToStagingArea = createCopyFilesTask(
  "copyDocumentationToStagingArea",
  "Copy documentation into the Unity plugin packaging dir.",
  [new File("CHANGELOG.md"),
   new File("LICENSE"),
   new File("README.md")],
  project.ext.scriptDirectory,
  new File(new File(new File(project.ext.pluginStagingAreaDir, "Assets"),
                    "ExternalDependencyManager"), "Editor"),
  [preparePluginStagingAreaDir],
  { sourceFile, targetFile -> copyAssetMetadataFile(sourceFile, targetFile) })

Iterable<Task> copyComponentsToStagingAreaTasks = [
    copyAndroidResolverStaging,
    copyVersionHandlerStaging,
    copyVersionHandlerImplStaging,
    copyIosResolverStaging,
    copyPackageManagerResolverStaging].collect {
  task ->
    createCopyFilesTask(
      sprintf("copy%sToStagingArea", task.ext.componentName),
      sprintf("Copy %s into the Unity plugin packaging dir.",
              task.ext.componentName),
      task.outputs.files.collect {
        new File(it.absolutePath - task.ext.stagingDir.absolutePath)
      },
      task.ext.stagingDir,
      new File(project.ext.pluginStagingAreaDir,
               project.ext.pluginEditorDllDir.path),
      [task], null)
}

task copyPluginComponentsToStagingArea(
  dependsOn: copyComponentsToStagingAreaTasks) {
  description "Copy plugin components into the Unity plugin packaging dir."
  outputs.files files(copyComponentsToStagingAreaTasks.collect {
                        task -> task.outputs.files
                      })
}

task generatePluginManifest(dependsOn: [preparePluginStagingAreaDir,
                                        copyPluginTemplateToStagingArea,
                                        copyDocumentationToStagingArea,
                                        copyPluginComponentsToStagingArea]) {
  String unversionedManifestName = currentPluginBasename + ".txt"
  File outputDir = new File(project.ext.pluginStagingAreaDir,
                            project.ext.pluginEditorDllDir.path)
  File manifestMetadataTemplateFile =
    new File(new File(project.ext.pluginTemplateDir,
                      project.ext.pluginEditorDllDir.path),
             unversionedManifestName + project.ext.unityMetadataExtension)
  File manifestFile = versionedAssetFile(
    new File(outputDir, unversionedManifestName),
    true,
    "_manifest",
    false)
  File manifestMetadataFile = versionedAssetFile(
    new File(outputDir, manifestMetadataTemplateFile.name),
    true,
    "_manifest",
    false)

  description "Generate a manifest for the files in the plug-in."
  inputs.files files(manifestMetadataTemplateFile)
  outputs.files files(manifestFile, manifestMetadataFile)

  doLast {
    List<String> filenameList = []
    (new File(project.ext.pluginStagingAreaDir, "Assets")).eachFileRecurse(
        groovy.io.FileType.FILES) { File fileObj ->
      String absolutePath = fileObj.absolutePath
      String absolutePathLowerCase = absolutePath.toLowerCase()
      if (!(absolutePathLowerCase.endsWith(
              project.ext.unityMetadataExtension) ||
            absolutePathLowerCase.endsWith(".txt"))) {
        filenameList.add(
          absolutePath.replace(
            project.ext.pluginStagingAreaDir.absolutePath + File.separator, ""))
      }
    }
    manifestFile.write(filenameList.toSorted().join("\n") + "\n")
    copyAssetMetadataFile(manifestMetadataTemplateFile, manifestMetadataFile)
  }
}

// Deprecated target for packaging the plugin.
Task buildPluginWithUnity = createUnityTask(
    "buildPluginWithUnity", "build_plugin", [generatePluginManifest],
    project.ext.pluginStagingAreaDir.name,
    project.ext.buildDir,
    ["-g.building",
     "-buildTarget", "android",
     "-exportPackage"] + (project.ext.pluginExportDirs.collect { it.path }) +
    [project.ext.pluginExportFile.absolutePath,
     "-gvh_disable",
     "-quit"], true, null)
buildPluginWithUnity.with {
  description ("(Deprecated) Exports the plugin staging area directory as " +
               "a Unity package.")
  inputs.files files(copyPluginTemplateToStagingArea.outputs.files,
                     copyPluginComponentsToStagingArea.outputs.files)
  outputs.files files(project.ext.pluginExportFile)
}

Task buildPlugin = createExportUnityPackageTask(
  "buildPlugin",
  "Package the .unitypackage with export_unity_package.py.",
  [generatePluginManifest],
  new File(project.ext.scriptDirectory, "export_unity_package_config.json"),
  new File(project.ext.scriptDirectory, "export_unity_package_guids.json"),
  new File(project.ext.pluginStagingAreaDir, "Assets"),
  true,  // Enable .unitypackage export.
  false, // Disable UPM export.
  project.ext.pluginVersion,
  project.ext.pluginExportFile.parentFile,
  ["--enabled_sections", "unitypackage documentation"])
buildPlugin.with {
  outputs.files project.ext.pluginExportFile.absolutePath
}

// Guid paths for UPM package.
File upmPluginPackageDir = new File("com.google.external-dependency-manager",
    "ExternalDependencyManager")
File upmPluginEditorDir = new File(upmPluginPackageDir, "Editor")
File upmPluginDllDir = new File(upmPluginEditorDir, project.ext.pluginVersion)

Task genGuidUpm = createGenGuidTask(
  "genGuidUpm",
  "Generate GUID for .tgz packaging.",
  new File(project.ext.scriptDirectory, "export_unity_package_guids.json"),
  project.ext.pluginVersion,
  [upmPluginDllDir.path]
)

Task buildUpmPlugin = createExportUnityPackageTask(
  "buildUpmPlugin",
  "Package the .tgz with export_unity_package.py.",
  [generatePluginManifest, genGuidUpm],
  new File(project.ext.scriptDirectory, "export_unity_package_config.json"),
  new File(project.ext.scriptDirectory, "export_unity_package_guids.json"),
  new File(project.ext.pluginStagingAreaDir, "Assets"),
  false, // Disable .unitypackage export.
  true,  // Enable UPM export.
  project.ext.pluginVersion,
  project.ext.pluginUpmExportFile.parentFile,
  [])
buildUpmPlugin.with {
  outputs.files project.ext.pluginUpmExportFile.absolutePath
}

task releasePlugin(dependsOn: [buildPlugin, buildUpmPlugin]) {
  Map<File, File> pluginTemplateFilesMap = files(
      copyPluginTemplateToStagingArea.outputs.files,
      copyPluginComponentsToStagingArea.outputs.files).collectEntries {
    File inputFile ->
      return (
        inputFile.name.endsWith(project.ext.unityMetadataExtension) ?
        [inputFile,
         new File(
           project.ext.pluginTemplateDir,
           unversionedAssetFile(
             new File(inputFile.absolutePath -
                      project.ext.pluginStagingAreaDir.absolutePath)).path)] :
        [:])
  }

  description "Copy the plugin to release locations."
  inputs.files files(project.ext.pluginExportFile,
                     pluginTemplateFilesMap.keySet())
  outputs.files files(project.ext.pluginReleaseFile,
                      fileTree(dir: project.ext.pluginExplodedDir),
                      pluginTemplateFilesMap.values())
  doLast {
    delete fileTree(
      dir: project.ext.pluginReleaseFile.parentFile,
      includes: [project.ext.currentPluginBasename + "-*.unitypackage"])
    copy {
      from project.ext.pluginExportFile
      into project.ext.pluginReleaseFile.parentFile
      rename { src_filename -> project.ext.pluginReleaseFile.name }
    }
    copy {
      from project.ext.pluginExportFile
      into project.ext.pluginReleaseFileUnversioned.parentFile
      rename { src_filename -> project.ext.pluginReleaseFileUnversioned.name }
    }
    delete fileTree(dir: project.ext.pluginExplodedDir)
    copy {
      from project.ext.pluginStagingAreaDir
      into project.ext.pluginExplodedDir
      include project.ext.pluginExportDirs.collect {
        it.path + "/**/*"
      }
    }
    pluginTemplateFilesMap.each {
      sourceFile, targetFile -> copyFile(sourceFile, targetFile)
    }
    println sprintf("Packaged to %s", project.ext.pluginReleaseFile)
  }
}

task gitAddReleaseFilesToStaging(type: Exec, dependsOn: releasePlugin) {
  description "Run git to add release to the staging area."
  commandLine "git", "add", "-A"
}

/*
 * Read the changes applied to the current version from the changelog.
 *
 * @returns Version summary in a multiline string.
 */
String readVersionSummaryFromChangelog() {
  String versionSummary = ""
  Boolean foundVersion = false
  for (String line in project.ext.changelog.text.tokenize("\n")) {
    String trimmedLine = line.trim()
    if (line =~ /^# Version/) {
      if (foundVersion) break
      foundVersion = true
    }
    versionSummary += line.replace("#", "-") + "\n"
  }
  return versionSummary
}

/*
 * Create a commit message for a release commit.
 *
 * @returns Commit message string.
 */
String createCommitMessage() {
  return sprintf("Version %s\n\n%s",
                 project.ext.pluginVersion,
                 readVersionSummaryFromChangelog())
}

task gitCreateReleaseCommit(dependsOn: gitAddReleaseFilesToStaging) {
  description "Run git to create a release commit."

  doLast {
    def stdout = new ByteArrayOutputStream()
    exec {
      commandLine "git", "status", "-s"
      ignoreExitValue true
      standardOutput = stdout
    }
    if (!stdout.toString().isEmpty()) {
      exec {
        commandLine "git", "commit", "-a", "-m", createCommitMessage()
      }
    }
  }
}

task gitTagRelease(type: Exec) {
  description ("Run git to tag a release.  This should be performed " +
               "*after* a release commit has been be created.")
  commandLine "git", "tag", "-a",
              sprintf("v%s", pluginVersion), "-m",
              sprintf("%s\n\nDownload [here](%s)",
                      createCommitMessage(),
                      sprintf("https://github.com/googlesamples/" +
                              "unity-jar-resolver/raw/v%s/" +
                              "external-dependency-manager-%s.unitypackage",
                              project.ext.pluginVersion,
                              project.ext.pluginVersion))
}

// TODO: Version Handler tests to implement in both batch and interactive modes
// - Per platform targeting (iOS, Android, Editor, desktop)
// - Version enablement, import newer plugin on top of older plugin and validate
//   new plugin is enabled, old plugin is removed.
// - Linux library renaming (need to override LibraryPrefix to test)
// - Canonical filename renaming for versioned filenames
// - Change settings, restore default settings.
// - Import plugin into a project and wait for asset processor to enable it.
// - Switch .NET version, validate DLLs are enabled / disabled as expected.

// TODO: Android Resolver tests to implement in both batch and interactive modes
// - Resolve with:
//   - Conflicting dependencies
//   - FAT ABI vs. single ABI selection

// TODO: iOS Resolver tests (on OSX only)
// - Import plugin test Cocoapods bootstrap
// - Pod specification, with reflection & XML, validate both are present in the
//   set.
// - Workspace export (Unity 5.6 and above)
// - Project export
// - Add a pod which changes the target SDK

Task compileVersionHandlerImplTests = createXbuildTask(
    "compileVersionHandlerImplTests",
    "Compile tests for VersionHandlerImpl.",
    project.ext.pluginSolutionFile, "VersionHandlerImplTests",
    fileTree(new File(
               new File(
                 new File(project.ext.pluginSourceDir,
                          "VersionHandlerImpl"),
                 "unit_tests"),
               "src")),
    new File(project.ext.testDir, "VersionHandlerImplTests"),
    [new File("Google.VersionHandlerImplTests.dll")], []).with {
  doFirst { checkNUnitDllPath() }
}

createNUnitTask(
  "testVersionHandlerImpl",
  "Runs tests for the VersionHandlerImpl module",
  compileVersionHandlerImplTests.outputs.files[0],
  [compileVersionHandlerImplTests])

Task compilePackageManagerResolverTests = createXbuildTask(
    "compilePackageManagerResolverTests",
    "Compile tests for PackageManagerResolver.",
    project.ext.pluginSolutionFile,
    "PackageManagerResolverTests",
    fileTree(new File(
               new File(
                 new File(project.ext.pluginSourceDir,
                          "PackageManagerResolver"),
                 "unit_tests"),
               "src")),
    new File(project.ext.testDir, "PackageManagerResolverTests"),
    [new File("Google.PackageManagerResolverTests.dll")],
    [buildPackageManagerResolver]).with {
  doFirst { checkNUnitDllPath() }
}

createNUnitTask(
  "testPackageManagerResolver",
  "Runs tests for the PackageManagerResolver module",
  compilePackageManagerResolverTests.outputs.files[0],
  [compilePackageManagerResolverTests])

createUnityTestBatchAndNonBatch(
  "testVersionHandlerActivation",
  ("Imports the plugin into a Unity project and verifies all " +
   "components can be activated by the Version Handler."),
  [buildPlugin],
  new File(project.ext.scriptDirectory,
           "source/VersionHandlerImpl/test/activation"),
  [], [], null)

// Launch the test via a script that runs a local web server.
createUnityTestBatchAndNonBatch(
  "testVersionHandlerWebRequest",
  ("Imports the plugin into a Unity project tests the PortableWebRequest " +
   "class."),
  [buildPlugin],
  new File(project.ext.scriptDirectory,
           "source/VersionHandlerImpl/test/webrequest"),
  [], [],
  { String name, String description, Iterable<Task> depends,
    File executable, Iterable<String> args ->
      Iterable<String> runnerArgs = [executable.absolutePath] + args
      return createPythonTask(
        name, description, depends,
        new File(
          new File(
            new File(project.ext.pluginSourceDir,
                     "VersionHandlerImpl"),
            "test"),
          "webrequest_launcher.py"),
        runnerArgs,
        [])
  })

createUnityTestBatchAndNonBatch(
  "testVersionHandlerReflection",
  ("Imports the plugin into a Unity project and tests reflection " +
   "methods."),
  [buildPlugin],
  new File(project.ext.scriptDirectory,
           "source/VersionHandler/test/reflection"),
  [],
  [],
  null)

Task compileIntegrationTester = createXbuildTask(
  "compileIntegrationTester",
  "Compile Integration Tester module.",
  project.ext.pluginSolutionFile,
  "IntegrationTester",
  fileTree(new File(project.ext.pluginSourceDir,
                    "IntegrationTester")),
  new File(project.ext.buildDir, "IntegrationTester"),
  [new File("Google.IntegrationTester.dll")],
  [compileVersionHandler])

/*
 * Creates a task which compiles and run a Unity integration test.
 *
 * @param taskName Name of the test.
 * @param description Description of the task.
 * @param dependsOn Dependencies of the new task.
 * @param integrationTestProject Project within
 *   project.ext.pluginSolutionFile that contains the integration test.
 * @param integrationTestProjectSources Source files integrationTestProject
 *  requires.
 * @param integrationTestProjectOutputs Assemblies generated by the
 *   integrationTestProject.
 * @param unityProjectDir Directory containing a assets to copy into the
 *   integration test project.
 * @param arguments Additional arguments for Unity when running the integration
 *   test.
 */
Task createUnityIntegrationTest(String taskName,
                                String description,
                                Iterable<Task> dependsOn,
                                String integrationTestProject,
                                Iterable<File> integrationTestProjectSources,
                                Iterable<File> integrationTestProjectOutputs,
                                File unityProjectDir,
                                Iterable<String> arguments) {
  Task compileIntegrationTest = createXbuildTask(
    sprintf("compile%s", integrationTestProject),
    sprintf("Compile %s for %s", integrationTestProject, taskName),
    project.ext.pluginSolutionFile,
    integrationTestProject,
    integrationTestProjectSources,
    new File(project.ext.buildDir, integrationTestProject),
    integrationTestProjectOutputs,
    [compileIntegrationTester] + dependsOn)

  createUnityTestBatchAndNonBatch(
    taskName,
    description,
    [buildPlugin],
    unityProjectDir,
    compileIntegrationTest.outputs.files +
    compileIntegrationTester.outputs.files,
    arguments, null)
}

createUnityIntegrationTest(
  "testAndroidResolverIntegrationTests",
  ("Imports the plugin into a Unity project, runs Android resolution with " +
   "a combination of dependencies added via the programmatic API and via " +
   "XML files, verifying all dependencies resolve successfully."),
  [compileAndroidResolver],
  "AndroidResolverIntegrationTests",
  fileTree(new File(new File(project.ext.pluginSourceDir, "AndroidResolver"),
                    "test")),
  [new File("Google.AndroidResolverIntegrationTests.dll")],
  new File(
    project.ext.scriptDirectory,
    "source/AndroidResolver/test/AndroidResolverIntegrationTestsUnityProject"),
  ["-buildTarget", "android"])

createUnityIntegrationTest(
  "testPackageManagerClientIntegrationTests",
  ("Imports the plugin into a Unity project and uses the Unity Package " +
   "Manager client to list, search, install and remove packages. "),
  [compilePackageManagerResolver],
  "PackageManagerClientIntegrationTests",
  fileTree(new File(new File(new File(project.ext.pluginSourceDir,
                             "PackageManagerResolver"), "test"),
                    "PackageManagerClientIntegrationTests")),
  [new File("Google.PackageManagerClientIntegrationTests.dll"),
   new File("Google.PackageManagerClientIntegrationTests.dll.mdb")],
  null, [])

task cleanTests(type: Delete) {
  description "Clean test directories."
  delete project.ext.testDir
}

task cleanAll(type: Delete) {
  description "Clean the build directory."
  delete project.ext.buildDir
}

project.defaultTasks = ["build", "test", "release", "clean"].collect {
  topLevelTaskName ->
    tasks.create(name: topLevelTaskName,
                 description: sprintf("Run all %s tasks",
                                      topLevelTaskName),
                 type: Task,
                 dependsOn: project.tasks.findAll {
                   task -> task.name.startsWith(topLevelTaskName)
                 })
}
