/*
 * Gradle file to build the Jar Resolver Unity plugin.
 */
buildscript {
  repositories {
    mavenCentral()
    mavenLocal()
  }
}

plugins {
  id "com.jetbrains.python.envs" version "0.0.30"
}

/*
 * Project level variables
 */
project.ext {
  // Set of properties to cache in the project.properties file.
  Properties cacheProperties = new Properties()

  // Set of directories to *not* search under the Unity root directory when
  // searching for components of Unity.
  String unitySearchDirExcludesString = findProperty("UNITY_EXCLUDES")
  String[] unitySearchDirExcludes =
    unitySearchDirExcludesString ?
      unitySearchDirExcludesString.tokenize(";") : []

  // Save the current OS.
  operatingSystem = OperatingSystem.getOperatingSystem()

  // Default installation path for Unity based upon the host operating system.
  List<String> defaultUnityPaths =
    [(OperatingSystem.UNKNOWN): ["Unity"],
     (OperatingSystem.MAC_OSX):
     ["/Applications/Unity/Unity.app/Contents/MacOS/Unity"] +
     (new FileNameFinder()).getFileNames(
       "/", "Applications/Unity/Hub/Editor/*/Unity.app/Contents/MacOS/Unity"),
     (OperatingSystem.WINDOWS):
     ["\\Program Files\\Unity\\Editor\\Unity.exe"] +
     (new FileNameFinder()).getFileNames(
       "\\", "Program Files\\Unity\\Hub\\Editor\\*\\Editor\\Unity.exe"),
     (OperatingSystem.LINUX): ["/opt/Unity/Editor/Unity"]][operatingSystem]

  // Search for the Unity editor executable.
  // The Unity editor is required to package the plug-in.
  for (defaultUnityPath in defaultUnityPaths) {
    unityExe = findFileProperty("UNITY_EXE", new File(defaultUnityPath), false)
    if (unityExe != null && unityExe.exists()) break;
  }
  if (unityExe == null || !unityExe.exists()) {
    unityExe = findFileInPath(unityExe.name)
  }
  if (unityExe == null) {
    throw new StopActionException("Unity editor executable (UNITY_EXE) not " +
                                  "found")
  }
  saveProperty("UNITY_EXE", unityExe, cacheProperties)

  // Path fragment that is the parent of the unity executable install location.
  // This is used to find the unity root directory from the editor executable.
  String unityExeParentPath =
    [(OperatingSystem.UNKNOWN): "Editor",
     (OperatingSystem.MAC_OSX): "Unity.app/Contents/MacOS",
     (OperatingSystem.WINDOWS): "Editor",
     (OperatingSystem.LINUX): "Editor"][operatingSystem]
  File unityRootDir = findFileProperty(
    "UNITY_DIR", new File(unityExe.parentFile.absolutePath -
                          unityExeParentPath), true)
  if (unityRootDir == null) {
    throw new StopActionException("Unity root directory (UNITY_DIR) not found.")
  }
  saveProperty("UNITY_DIR", unityRootDir, cacheProperties)

  FileTree unityRootDirTree = fileTree(dir: unityRootDir)

  // Find unity engine dll under the root directory.
  unityDllPath = getFileFromPropertyOrFileTree(
    "UNITY_DLL_PATH", true, {
      unityRootDirTree.matching {
        include "**/Managed/UnityEngine.dll"
        exclude unitySearchDirExcludes
      }
    })
  if (unityDllPath == null) {
    throw new StopActionException(
      "UnityEngine.dll and UnityEditor.dll directory (UNITY_DLL_PATH) " +
      "not found.")
  }
  saveProperty("UNITY_DLL_PATH", unityDllPath, cacheProperties)

  // iOS runtime dll.  This is with the playback engine, so the
  // structure is different for MacOS and the others.
  unityIosPath = getFileFromPropertyOrFileTree(
    "UNITY_IOS_PLAYBACK_PATH", true, {
      unityRootDirTree.matching {
        include "**/PlaybackEngines/iOSSupport/UnityEditor.iOS.Extensions.dll",
        "**/PlaybackEngines/iossupport/UnityEditor.iOS.Extensions.dll"
        exclude unitySearchDirExcludes
      }
    })
  if (unityIosPath == null) {
    // iOS support is *required* to build the iOS resolver.
    throw new StopActionException(
      "UnityEditor.iOS.Extensions.dll directory (UNITY_IOS_PLAYBACK_PATH) " +
      "not found.")
  }
  saveProperty("UNITY_IOS_PLAYBACK_PATH", unityIosPath, cacheProperties)

  // Find xbuild to build the dlls.
  xbuildExe = getFileFromPropertyOrFileTree(
    "XBUILD_EXE", false, {
      unityRootDirTree.matching {
        include (operatingSystem == OperatingSystem.WINDOWS ?
                 "**/bin/xbuild.bat" : "**/xbuild")
        exclude unitySearchDirExcludes
      }
    })
  if (xbuildExe == null) {
    throw new StopActionException("xbuild not found (XBUILD_EXE)")
  }
  saveProperty("XBUILD_EXE", xbuildExe, cacheProperties)

  // Find mono to determine the distribution being used.
  monoExe = getFileFromPropertyOrFileTree(
    "MONO_EXE", false, {
      unityRootDirTree.matching {
        include (operatingSystem == OperatingSystem.WINDOWS ?
          "**/bin/mono.bat" : "**/bin/mono")
        exclude unitySearchDirExcludes
      }
    })
  saveProperty("MONO_EXE", monoExe, cacheProperties)

  // Get the mono distribution version.
  def versionRegEx = /^.* version ([^ ]+) .*/
  def stdout = new ByteArrayOutputStream()
  exec {
    commandLine monoExe, "-V"
    ignoreExitValue true
    standardOutput = stdout
  }
  def monoVersionList =
    stdout.toString().replace("\r\n", "\n").tokenize("\n").findResults {
      def versionMatch = it =~ versionRegEx
      if (versionMatch.matches()) {
        return versionMatch.group(1)
      }
      return null
    }
  if (!monoVersionList) {
    throw new StopActionException(
      sprintf("Unable to determine mono version from %s", monoExe))
  }
  monoVersion = monoVersionList[0]

  // Mono 5.x and above generate .pdb files that are compatible with visual
  // studio as opposed to the mono-specific .pdb files.
  pdbSupported = monoVersion.tokenize(".")[0].toInteger() >= 5

  if (pdbSupported) {
    logger.warn(
      sprintf("Mono %s detected which will generate .pdb files " +
              "that are not compatible with older versions of Unity. " +
              "This can be fixed by compiling with Unity 5.6.",
              monoVersion))
  }

  // Get the directory that contains this script.
  scriptDirectory = buildscript.sourceFile.getParentFile()

  // It can take a while to search for build tools, so cache paths in the project
  // properties.
  File projectPropertiesFile = new File(scriptDirectory,"gradle.properties")
  if (!projectPropertiesFile.exists()) {
    logger.info(sprintf("Saving %s to %s",
                        cacheProperties.stringPropertyNames(),
                        projectPropertiesFile))
    cacheProperties.store(projectPropertiesFile.newWriter(), null)
  }

  // UnityAssetUploader required environment variables.
  unityUsername = findProperty("UNITY_USERNAME")
  unityPassword = findProperty("UNITY_PASSWORD")
  unityPackageId = findProperty("UNITY_PACKAGE_ID")
  unityPackagePath = findFileProperty("UNITY_PACKAGE_PATH", null)

  // Whether debug symbols should be included.
  debugEnabled = true

  // Whether interactive mode tests are enabled.
  interactiveModeTestsEnabled =
    findProperty("INTERACTIVE_MODE_TESTS_ENABLED", "1") == "1"

  // Whether to continue to the next test if one fails.
  continueOnFailForTestsEnabled =
    findProperty("CONTINUE_ON_FAIL_FOR_TESTS_ENABLED", "1") == "1"

  // List of test sessions
  testSessions = []

  // List of test types that should be included. Controlled by
  // "INCLUDE_TEST_TYPES" property. Includes every tests if the property is
  // empty.
  // DO NOT USE THIS FOR FILTER, Use `actualIncludeTestTypes` instead.
  includeTestTypesParam =
    TestTypeEnum.toSet(
      findProperty("INCLUDE_TEST_TYPES", "").split('\\s+|\\s*,\\s*').toList(),
      true)

  // List of test types that should be excluded. Controlled by
  // "EXCLUDE_TEST_TYPES" property. Excludes none if the property is
  // empty.
  // DO NOT USE THIS FOR FILTER, Use `actualIncludeTestTypes` instead.
  excludeTestTypesParam =
    TestTypeEnum.toSet(
      findProperty("EXCLUDE_TEST_TYPES", "").split('\\s+|\\s*,\\s*').toList(),
      false)

  // The actual list of test types to run.
  actualIncludeTestTypes = includeTestTypesParam.clone()
  actualIncludeTestTypes.removeAll(excludeTestTypesParam)

  // List of test modules that should be included. Controlled by
  // "INCLUDE_TEST_MODULES" property. Includes every tests if the property is
  // empty.
  // DO NOT USE THIS FOR FILTER, Use `actualIncludeTestModules` instead.
  includeTestModulesParam =
    TestModuleEnum.toSet(
      findProperty("INCLUDE_TEST_MODULES", "").split('\\s+|\\s*,\\s*').toList(),
      true)

  // List of test modules that should be excluded. Controlled by
  // "EXCLUDE_TEST_MODULES" property. Excludes none if the property is
  // empty.
  // DO NOT USE THIS FOR FILTER, Use `actualIncludeTestModules` instead.
  excludeTestModulesParam =
    TestModuleEnum.toSet(
      findProperty("EXCLUDE_TEST_MODULES", "").split('\\s+|\\s*,\\s*').toList(),
      false)

  // The actual list of test module to run.
  actualIncludeTestModules = includeTestModulesParam.clone()
  actualIncludeTestModules.removeAll(excludeTestModulesParam)

  // List of tests to exclude. Controlled by "EXCLUDE_TESTS" property. Excludes
  // none if the property is empty.
  excludeTestsParam =
    new HashSet(findProperty("EXCLUDE_TESTS", "").toLowerCase().split('\\s+|\\s*,\\s*').toList())

  // Directory for intermediate and final build outputs.
  buildDir = new File(scriptDirectory, "build")
  // Directory for external tools.
  externalToolsDir = new File(scriptDirectory, "external_tools")
  // Directory for testing.
  testDir = new File(scriptDirectory, "test_output")
  // Version of the plugin (update this with CHANGELOG.md on each release).
  pluginVersion = "1.2.179"
  // Directory that contains the template plugin.
  // Files under this directory are copied into the staging area for the
  // plugin.
  pluginTemplateDir = new File(scriptDirectory, "plugin")
  // Directory where the plugin is staged to be exported as a Unity package.
  pluginStagingAreaDir = new File(buildDir, "staging")
  // Directory where the build plugin is unpacked to.
  pluginExplodedDir = new File(scriptDirectory, "exploded")
  // Directory where the UPM package is unpacked to.
  pluginUpmDir = new File(scriptDirectory, "upm")
  // Base filename of the released plugin.
  currentPluginBasename = "external-dependency-manager"
  // Base UPM package name of the released plugin.
  currentPluginUpmPackageName = "com.google.external-dependency-manager"
  // Where the exported plugin file is built before it's copied to the release
  // location.
  pluginExportFile = new File(buildDir, currentPluginBasename + ".unitypackage")
  // Where the exported UPM plugin file is built.
  pluginUpmExportFile = new File(buildDir,
                                 currentPluginUpmPackageName + "-" + pluginVersion + ".tgz")
  // Directory within the plugin staging area that just contains the plugin.
  pluginAssetsDir = new File("Assets", "ExternalDependencyManager")
  // Directories within the staging area to export.
  pluginExportDirs = [pluginAssetsDir, new File("Assets", "PlayServicesResolver")]
  // Directory within the plugin directory that contains the managed DLLs.
  pluginEditorDllDir = new File(pluginAssetsDir, "Editor")
  // Directory which contains the solution for all C# projects with a project in
  // each subdirectory.
  pluginSourceDir = new File(scriptDirectory, "source")
  // Solution which references all projects used by the plugin.
  pluginSolutionFile = new File(pluginSourceDir, "ExternalDependencyManager.sln")
  // Versioned release plugin file.
  pluginReleaseFile = new File(scriptDirectory,
                               sprintf("%s-%s.unitypackage",
                                       currentPluginBasename,
                                       pluginVersion))
  // Unversioned release plugin file.
  pluginReleaseFileUnversioned = new File(scriptDirectory,
                                          sprintf("%s-latest.unitypackage",
                                                  currentPluginBasename))

  // Location of the Unity asset uploader application.
  unityAssetUploaderDir = new File(pluginSourceDir, "UnityAssetUploader")

  // Location of the export_unity_package application.
  exportUnityPackageDir = new File(pluginSourceDir, "ExportUnityPackage")
  // Location of the import_unity_package application.
  importUnityPackageDir = new File(pluginSourceDir, "ImportUnityPackage")

  // Common arguments used to execute Unity in batch mode.
  unityBatchModeArguments = ["-batchmode", "-nographics"]
  // Common arguments used to execute Unity in interactive mode.
  unityInteractiveModeArguments = ["-gvh_noninteractive"]
  // Extension for Unity asset metadata files.
  unityMetadataExtension = ".meta"
  // Extensions for debug files.
  symbolDatabaseExtension = pdbSupported ? ".pdb" : ".dll.mdb"
  // Changelog file.
  changelog = new File(scriptDirectory, "CHANGELOG.md")
  pythonBootstrapDir = new File(externalToolsDir, "python_bootstrap")
  pythonBinDir = new File(new File(pythonBootstrapDir, "python"), "bin")
  // Python binary after it has been bootstrapped.
  pythonExe = new File(pythonBinDir, "python3")
  // Pip binary after it has been bootstrapped.
  pipExe = new File(pythonBinDir, "pip3")
  // Python packages required by export_unity_package.py
  exportUnityPackageRequirements = ["absl-py", "PyYAML", "packaging"]
  // Python packages required by gen_guids.py
  genGuidRequirements = ["absl-py"]
}

// Configure com.jetbrains.python.envs to bootstrap a Python install.
envs {
  bootstrapDirectory = project.ext.pythonBootstrapDir
  envsDirectory = new File(project.ext.buildDir, "python_envs")
  python "python", "3.9.5"
}

/*
 * Host operating system.
 */
public enum OperatingSystem {
  UNKNOWN, MAC_OSX, WINDOWS, LINUX

  /*
   * Get the current operating system.
   *
   * @returns Current host operating system.
   */
  public static OperatingSystem getOperatingSystem() {
    String os_name = System.getProperty("os.name").toLowerCase()
    if (os_name.contains("mac os x")) {
      return OperatingSystem.MAC_OSX
    } else if (os_name.contains("windows")) {
      return OperatingSystem.WINDOWS
    } else if (os_name.contains("linux")) {
      return OperatingSystem.LINUX
    }
    return OperatingSystem.UNKNOWN
  }
}

/*
 * Test Types
 */
public enum TestTypeEnum {
  INTEGRATION,    // Unity Integration Tests using IntegrationTester framework.
  NUNIT,          // Tests using NUnit framework
  PYTHON,         // Tests implemented in Python
  GRADLE          // Tests implemented in Gradle scripts

  // A complete set of all enums
  private static HashSet<TestTypeEnum> completeSet;

  /*
   * Get a complete set of all enums
   *
   * @returns A complete set of all enums
   */
  private static HashSet<TestTypeEnum> getCompleteSet() {
    if (completeSet == null) {
      completeSet = new HashSet<TestTypeEnum>()
      for (TestTypeEnum type : TestTypeEnum.values()) {
        completeSet.add(type);
      }
    }
    return completeSet.clone()
  }

  /*
   * Convert a list of strings to a set of enums
   *
   * @param values A list of case-insensitive strings to convert to enum.
   * @param completeSetWhenEmpty Whether to return a complete set if the list
   *        is empty.
   *
   * @returns A set of enums
   */
  public static HashSet<TestTypeEnum> toSet(
      Collection<String> values, Boolean completeSetWhenEmpty) {
    def result = new HashSet<TestTypeEnum>()
    if ( values == null) {
      return completeSetWhenEmpty ? getCompleteSet() : result;
    }
    for (String value : values) {
      def trimmed = value.trim().toUpperCase()
      if (!trimmed.isEmpty()) {
        result.add(TestTypeEnum.valueOf(trimmed))
      }
    }
    if (result.size() == 0) {
      result = completeSetWhenEmpty ? getCompleteSet() : result;
    }
    return result
  }
}

/*
 * Test Modules
 */
public enum TestModuleEnum {
  ANDROIDRESOLVER,    // Tests for Android Resolver
  VERSIONHANDLER,     // Tests for Version Handler
  IOSRESOLVER,        // Tests for iOS Resolver
  PACKAGEMANAGER,     // Tests for Package Manager
  CORE,               // Tests for reusable C# libraries
  TOOL                // Tests for build/packaging/release tools

  // A complete set of all enums
  private static HashSet<TestModuleEnum> completeSet;

  /*
   * Get a complete set of all enums
   *
   * @returns A complete set of all enums
   */
  private static HashSet<TestModuleEnum> getCompleteSet() {
    if (completeSet == null) {
      completeSet = new HashSet<TestModuleEnum>()
      for (TestModuleEnum type : TestModuleEnum.values()) {
        completeSet.add(type);
      }
    }
    return completeSet.clone()
  }

  /*
   * Convert a list of strings to a set of enums
   *
   * @param values A list of case-insensitive strings to convert to enum.
   * @param completeSetWhenEmpty Whether to return a complete set if the list
   *        is empty.
   *
   * @returns A set of enums
   */
  public static HashSet<TestModuleEnum> toSet(
      Collection<String> values, Boolean completeSetWhenEmpty) {
    def result = new HashSet<TestModuleEnum>()
    if ( values == null) {
      return completeSetWhenEmpty ? getCompleteSet() : result;
    }
    for (String value : values) {
      def trimmed = value.trim().toUpperCase()
      if (!trimmed.isEmpty()) {
        result.add(TestModuleEnum.valueOf(trimmed))
      }
    }
    if (result.size() == 0) {
      result = completeSetWhenEmpty ? getCompleteSet() : result;
    }
    return result
  }
}

/*
 * Determine whether the test should be run given the filter parameters,
 * the current test type and the current test module
 *
 * @param type Type of the test.
 * @param module Module of the test.
 *
 * @returns True if the test should be run by the given the filters.
 */
boolean shouldTestRunWithFilters(TestTypeEnum type, TestModuleEnum module) {
  project.ext.actualIncludeTestTypes.contains(type) &&
  project.ext.actualIncludeTestModules.contains(module)
}

/*
 * Set the test type and module to the given task.
 *
 * @param task The task to set the properties to.
 * @param type Type of the test.
 * @param module Module of the test.
 */
void setTestProperties(Task task, TestTypeEnum type, TestModuleEnum module) {
  task.ext.testType = type
  task.ext.testModule = module
}

/*
 * Unit test for TestTypeEnum
 */
task(testTestTypeEnum) { task ->
  setTestProperties(task, TestTypeEnum.GRADLE, TestModuleEnum.TOOL)
  doFirst {
    ReportTestStarted(task)
  }
  doLast {
    def expectedTestTypeEnumCompleteSet =
      new HashSet([
        TestTypeEnum.INTEGRATION,
        TestTypeEnum.NUNIT,
        TestTypeEnum.PYTHON,
        TestTypeEnum.GRADLE])
    def expectedEmptySet = new HashSet()
    def expectedPythonOnlySet = new HashSet([TestTypeEnum.PYTHON])
    def expectedPythonAndIntegrationSet = new HashSet([
      TestTypeEnum.PYTHON,
      TestTypeEnum.INTEGRATION])

    assert TestTypeEnum.getCompleteSet().equals(
           expectedTestTypeEnumCompleteSet)
    assert TestTypeEnum.toSet([], false).equals(
           expectedEmptySet)
    assert TestTypeEnum.toSet([], true).equals(
           expectedTestTypeEnumCompleteSet)
    assert TestTypeEnum.toSet(["python"], false).equals(
           expectedPythonOnlySet)
    assert TestTypeEnum.toSet(["python"], true).equals(
           expectedPythonOnlySet)
    assert TestTypeEnum.toSet(["PYTHON"], false).equals(
           expectedPythonOnlySet)
    assert TestTypeEnum.toSet(["PyThOn"], false).equals(
           expectedPythonOnlySet)
    assert TestTypeEnum.toSet(["Python", "Integration"], false).equals(
           expectedPythonAndIntegrationSet)
    assert TestTypeEnum.toSet(["Integration", "Python"], false).equals(
           expectedPythonAndIntegrationSet)
    assert TestTypeEnum.toSet(
           ["Integration", "Python", "Gradle", "NUnit"], false).equals(
           expectedTestTypeEnumCompleteSet)

    EvaluateTestResult(task)
  }
}

/*
 * Unit test for TestModuleEnum
 */
task(testTestModuleEnum) { task ->
  setTestProperties(task, TestTypeEnum.GRADLE, TestModuleEnum.TOOL)
  doFirst {
    ReportTestStarted(task)
  }
  doLast {
    def expectedTestModuleEnumCompleteSet =
      new HashSet([
        TestModuleEnum.ANDROIDRESOLVER,
        TestModuleEnum.VERSIONHANDLER,
        TestModuleEnum.IOSRESOLVER,
        TestModuleEnum.PACKAGEMANAGER,
        TestModuleEnum.CORE,
        TestModuleEnum.TOOL])
    def expectedEmptySet = new HashSet()
    def expectedToolOnlySet = new HashSet([TestModuleEnum.TOOL])
    def expectedToolAndAndroidResolverSet = new HashSet([
      TestModuleEnum.TOOL,
      TestModuleEnum.ANDROIDRESOLVER])

    assert TestModuleEnum.getCompleteSet().equals(
           expectedTestModuleEnumCompleteSet)
    assert TestModuleEnum.toSet([], false).equals(
           expectedEmptySet)
    assert TestModuleEnum.toSet([], true).equals(
           expectedTestModuleEnumCompleteSet)
    assert TestModuleEnum.toSet(["tool"], false).equals(
           expectedToolOnlySet)
    assert TestModuleEnum.toSet(["tool"], true).equals(
           expectedToolOnlySet)
    assert TestModuleEnum.toSet(["TOOL"], false).equals(
           expectedToolOnlySet)
    assert TestModuleEnum.toSet(["TooL"], false).equals(
           expectedToolOnlySet)
    assert TestModuleEnum.toSet(["Tool", "AndroidResolver"], false).equals(
           expectedToolAndAndroidResolverSet)
    assert TestModuleEnum.toSet(["AndroidResolver", "Tool"], false).equals(
           expectedToolAndAndroidResolverSet)
    assert TestModuleEnum.toSet([
             "AndroidResolver",
             "VersionHandler",
             "iOSResolver",
             "PackageManager",
             "Core",
             "Tool"], false).equals(
           expectedTestModuleEnumCompleteSet)
    EvaluateTestResult(task)
  }
}

/*
 * Test session
 */
public class TestSession {
  public String name;
  public TestTypeEnum type;
  public TestModuleEnum module;
  public Boolean isPassed;
}

/*
 * Search the path variable for an executable file.
 *
 * @param filename Name of the file to search for.
 *
 * @return If found, the File object that references the file, null otherwise.
 */
File findFileInPath(String filename) {
  def stdout = new ByteArrayOutputStream()
  exec {
    executable OperatingSystem.getOperatingSystem() == OperatingSystem.WINDOWS ?
      "where" : "which"
    args filename
    ignoreExitValue true
    standardOutput = stdout
  }
  String resultString = stdout.toString()
  return resultString.isEmpty() ? null : new File(resultString)
}

/*
 * Get a property value by name searching project properties, system properties
 * and environment variables.
 *
 * @param propertyName Name of the property to search for.
 * @param defaultValue Value of the property if it's not found.
 *
 * @returns Property value as string if found and not empty, null otherwise.
 */
String findProperty(String propertyName, String defaultValue = null) {
  Closure valueIsSet = {
    valueString -> valueString != null && !valueString.isEmpty()
  }
  String value = null
  for (def queryObject in [project, System]) {
    if (queryObject.hasProperty(propertyName)) {
      value = queryObject.getProperty(propertyName)
      if (valueIsSet(value)) {
        return value
      }
    }
  }
  value = System.getenv(propertyName)
  return valueIsSet(value) ? value : defaultValue
}

/*
 * Get a property value by name as a file, searching project properties,
 * system properties and environment variables.
 *
 * @param propertyName Name of the property to search for.
 * @param defaultValue Value of the property if it's not found.
 * @param mustExist Whether the file must exist.
 *
 * @returns Property value as a File if found and exists (if mustExist is true),
 *  null otherwise.
 */
File findFileProperty(String propertyName, File defaultValue = null,
                      Boolean mustExist = false) {
  String foundFilePath = findProperty(
    propertyName, defaultValue != null ? defaultValue.absolutePath : null)
  File foundFile = foundFilePath != null ? new File(foundFilePath) : null
  return foundFile != null && (!mustExist || foundFile.exists()) ?
    foundFile : null
}

/*
 * Get a File from the specified property or the shortest path in the specified
 * FileTree object.
 *
 * @param propertyName Property name to lookup prior to searching the tree
 *   for a matching file.
 * @param useParentDirectory If set to true, this returns a File object pointing
 *   at the parent directory of the file that is found.
 * @param fileTreeClosure Closure which returns a FileTree object to search.
 *
 * @return File if it's found and exists, null otherwise.
 */
File getFileFromPropertyOrFileTree(String propertyName,
                                   Boolean useParentDirectory,
                                   fileTreeClosure) {
  File fileValue = findFileProperty(propertyName, null, true)
  if (fileValue == null) {
    // Search for the shortest path to the require file.
    fileTreeClosure().files.each { currentFile ->
      if (fileValue == null ||
          fileValue.absolutePath.length() > currentFile.absolutePath.length()) {
        fileValue = currentFile
      }
    }
    if (useParentDirectory && fileValue != null) {
      fileValue = fileValue.parentFile
    }
  }
  return fileValue
}

/*
 * Set a project property and log it.
 *
 * @param name Name of the property.
 * @param value Value of the property.
 * @param properties Map of properties to save to.
 */
void saveProperty(String name, value, Properties properties) {
  if (value != null) properties.setProperty(name.toString(), value.toString())
  logger.info(sprintf("%s: %s", name, value))
}

/*
 * Removes the extension from a filename.
 *
 * @param fileObj File object to split into a basename and extension.
 *
 * @returns (basename, extension) tuple where basename is the filename without
 * an extension and extension is the extension.
 */
List<String> splitFilenameExtension(File fileObj) {
  String filename = fileObj.name
  String trimmedFilename = filename
  if (trimmedFilename.endsWith(project.ext.unityMetadataExtension)) {
    trimmedFilename -= project.ext.unityMetadataExtension
  }
  if (trimmedFilename.endsWith(".dll.mdb")) {
    trimmedFilename -= ".mdb"
  }
  int extensionIndex = trimmedFilename.lastIndexOf(".")
  if (extensionIndex < 0) return [filename, ""]
  String basename = filename.substring(0, extensionIndex)
  String extension = filename.substring(extensionIndex)
  return [basename, extension]
}

/*
 * Construct the name of a versioned asset from the source filename and version
 * string.  If fullVersionPrefix is true, the encoded string takes the form
 * ${filename}_version-${version}.${extension}
 * if fullVersionPrefix is false, the string takes the form
 * ${filename}_v${version}.${extension}
 * where extension is derived from the specified filename.
 *
 * @param fileObj File to add version to.
 * @param fullVersionPrefix if true uses the "_version-" otherwise uses "_v-".
 * @param postfix Optional string to add before the extensioon.
 * @param useVersionDir If true, place the file to be under a folder named after
 *        the version number, instead of changing the filename.
 *
 * @returns File which includes an encoded version.
 */
File versionedAssetFile(File fileObj, Boolean fullVersionPrefix,
                        String postfix, Boolean useVersionDir) {
  String basename
  String extension
  (basename, extension) = splitFilenameExtension(fileObj)
  // Encode the DLL version and target names into the DLL in the form...
  // ${dllname}_version-${version}.dll
  String targetName = basename
  String version = project.ext.pluginVersion
  File dllDir = fileObj.parent != null ? new File(fileObj.parent) :
        new File()
  if (!(version == null || version.isEmpty())) {
    if (useVersionDir) {
      dllDir = new File(dllDir, version)
    } else {
      targetName += (fullVersionPrefix ? "_version-" : "_v") + version
    }
  }
  String filename = targetName + postfix + extension
  return new File(dllDir, filename)
}

/*
 * Remove the version component from a path. (Both its filename and its parent
 * folder)
 *
 * @param fileObj File to remove version from.
 *
 * @returns File with removed version string.
 */
File unversionedAssetFile(File fileObj) {
  // Remove the version postfix. Ex.
  // "ExternalDependencyManager/Editor/Google.IOSResolver_v1.2.166.dll" ->
  // "ExternalDependencyManager/Editor/Google.IOSResolver.dll"
  String basename
  String extension
  (basename, extension) = splitFilenameExtension(fileObj)
  def versionRegExFull = /^(.*)_(version-[^-]+)$/
  def versionRegExShort = /^(.*)_(v[^v]+)$/
  def versionMatch = basename =~ versionRegExShort
  if (versionMatch.matches()) {
    basename = versionMatch.group(1)
  } else {
    versionMatch = basename =~ versionRegExFull
    if (versionMatch.matches()) {
      basename = versionMatch.group(1)
    }
  }
  String filename = basename + extension

  // Remove the version folder as well. Ex.
  // "ExternalDependencyManager/Editor/1.2.166/Google.IOSResolver.dll" ->
  // "ExternalDependencyManager/Editor/Google.IOSResolver.dll"
  def versionFolderRegEx = /^[0-9]+\.[0-9]+\.[0-9]+$/
  File parent = fileObj.parent != null ? new File(fileObj.parent) : null
  if (parent != null) {
      String parentFolder = parent.name
      def folderMatch = parentFolder =~ versionFolderRegEx
      if (folderMatch.matches()) {
          parent = parent.parent != null ? new File(parent.parent) : null
      }
  }
  return parent != null ? new File(parent, filename) : new File(filename)
}

/*
 * Copy a file.
 *
 * @param sourceFile File to copy.
 * @param targetFile File to write to.
 *
 * @returns targetFile.
 */
File copyFile(File sourceFile, File targetFile) {
  targetFile.parentFile.mkdirs()
  logger.info(sprintf("Copy %s -> %s", sourceFile.path, targetFile.path))
  targetFile.newOutputStream() << sourceFile.newInputStream()
  return targetFile
}

/*
 * Copy a list of files from one directory into another.
 *
 * @param taskName Name of the task.
 * @param taskDescription Description of the task.
 * @param filesToCopy List of files to copy with paths relative to the source
 * directory.
 * @param sourceDir Directory to copy files from.
 * @param targetDir Directory to copy files into preserving the relative path of
 * each file.
 * @param dependsOn List of dependencies for the task.
 * @param copyFileClosure Closure which takes (sourceFile, targetFile) to copy a
 * file.
 *
 * @returns Task which copies the specified files.  The ext.sourceTargetFileMap
 * property of the task contains the mapping of source to target files to be
 * copied by the task.
 */
Task createCopyFilesTask(String taskName, String taskDescription,
                         Iterable<File> filesToCopy, File sourceDir,
                         File targetDir, Iterable<Task> dependsOn,
                         Closure copyFileClosure) {
  Map<File, File> sourceTargetFileMap = filesToCopy.collectEntries {
    [(new File(sourceDir, it.path)), (new File(targetDir, it.path))]
  }
  if (!copyFileClosure) {
    copyFileClosure = {
      sourceFile, targetFile -> copyFile(sourceFile, targetFile)
    }
  }
  Task copyTask = tasks.create(name: taskName,
                               description: taskDescription,
                               type: Task,
                               dependsOn: dependsOn).with {
    inputs.files sourceTargetFileMap.keySet()
    outputs.files sourceTargetFileMap.values()
    doLast {
      sourceTargetFileMap.each { sourceFile, targetFile ->
        copyFileClosure(sourceFile, targetFile)
      }
    }
  }
  copyTask.ext.sourceTargetFileMap = sourceTargetFileMap
  return copyTask
}

/*
 * Copy a file, injecting release information if it's a Unity asset metadata
 * file.
 *
 * @param sourceFile File to copy from.
 * @param targetFile File to copy to.
 *
 * @return targetFile.
 */
File copyAssetMetadataFile(File sourceFile, File targetFile) {
  if (!sourceFile.name.endsWith(project.ext.unityMetadataExtension)) {
    return copyFile(sourceFile, targetFile)
  }
  String[] lines = sourceFile.text.tokenize("\n")

  // Parse the existing version from the asset metadata.
  def folderAssetRegEx = /^folderAsset:\s+yes\s*$/
  def versionRegEx = /^(-\s+gvh_version-)([a-zA-Z0-9.]+)\s*$/
  def exportPathRegEx = /^(-\s+gvhp_exportpath-)(.*)$/
  Boolean isFolder = false
  String currentVersion = ""
  lines.each { String line ->
    def versionMatch = line =~ versionRegEx
    def folderMatch = line =~ folderAssetRegEx
    if (versionMatch.matches()) {
      currentVersion = versionMatch.group(2)
    } else if (folderMatch.matches()) {
      isFolder = true
    }
  }
  Boolean isNotVersioned = (isFolder ||
                            targetFile.name.startsWith(
                                "play-services-resolver"))
  // Ignore folder assets, they don't need to be versioned.
  if (isNotVersioned) return copyFile(sourceFile, targetFile)
  Boolean versionChanged = currentVersion != project.ext.pluginVersion

  List<String> outputLines = []
  lines.each { line ->
    if (versionChanged) {
      def guidMatch = (line =~ /^(guid:)\s+(.*)/)
      def versionLabelMatch = (line =~ versionRegEx)
      def exportPathMatch = (line =~ exportPathRegEx)
      if (guidMatch.matches() && (sourceFile.name != targetFile.name ||
            sourceFile.parent != targetFile.parent ) ) {
        // Update the metadata's GUID.
        // If a file is renamed we want to make sure Unity imports it as a new
        // asset with the new filename.
        line = sprintf(
          "%s %s",
          guidMatch.group(1),
          java.util.UUID.randomUUID().toString().replace("-", ""))
      } else if (versionLabelMatch.matches()) {
        // Update the version metadata for the asset.
        line = sprintf("%s%s", versionLabelMatch.group(1),
                       project.ext.pluginVersion)
      } else if (exportPathMatch.matches()) {
        // Update the export path of the asset.
        line = sprintf("%s%s", exportPathMatch.group(1),
                       targetFile.path.replaceFirst(/.*\/Assets\//, ""))
        line = line.substring(0, line.length() -
                              project.ext.unityMetadataExtension.length())
      }
    }
    outputLines.add(line)
    // If the metadata file does not contain a version label, inject it.
    if (currentVersion.isEmpty() && line.startsWith("labels:")) {
      outputLines.add(sprintf("- gvh_version-%s", project.ext.pluginVersion))
    }
  }
  targetFile.write(outputLines.join("\n") + "\n")

  return targetFile
}

/*
 * Build a project with xbuild.
 *
 * @param taskName Name of the task.
 * @param taskDescription Description of the task.
 * @param projectToBuild Path to the project to build.
 * @param target Target to build in the project.
 * @param inputFiles Input files for the project.
 * @param outputDir Output directory.
 * @param outputFiles List of output file paths relative to the output
 * directory.
 * @param dependsOn List of dependencies for the task.
 *
 * @returns Task which builds the specified target.
 */
Task createXbuildTask(String taskName, String taskDescription,
                      File projectToBuild, String target,
                      Iterable<File> inputFiles, File outputDir,
                      Iterable<File> outputFiles, Iterable<Task> dependsOn) {
  File intermediatesDir = new File(outputDir, "obj")
  File binaryOutputDir = new File(outputDir, "bin")
  Iterable<File> outputFilesInBinaryOutputDir = outputFiles.collect {
    return new File(binaryOutputDir, it.path)
  }

  if (project.ext.debugEnabled) {
    outputFilesInBinaryOutputDir += outputFilesInBinaryOutputDir.findResults {
      return it.name.endsWith(".dll") ?
        new File(it.parentFile.path,
                 splitFilenameExtension(it)[0] +
                 project.ext.symbolDatabaseExtension) : null
    }
  }

  Iterable<Task> dependsOnTasks = dependsOn ? dependsOn : []
  Iterable<Task> compileTaskDependencies = dependsOnTasks.clone()
  Iterable<Task> patchVersionFilesTasks = inputFiles.findResults {
    if (it.name == "VersionNumber.cs") {
      File versionFile = it
      Task patchVersionTask = tasks.create(
        name: taskName + "AddVersionTo" + it.name,
        description: "Add version to " + it.path,
        type: Task,
        dependsOn: dependsOnTasks)
      patchVersionTask.with {
        inputs.files files([versionFile])
        outputs.files files([versionFile])
        doLast {
          String[] lines = versionFile.text.split("\n")
          List<String> outputLines = lines.collect {
            it.replaceAll(
              /(^.*VERSION_STRING[ ]*=[ ]*\")([^\"]+)(\".*)/,
              '$1' + project.ext.pluginVersion + '$3')
          }
          String patchedFileString = (outputLines.join("\n") + "\n")
          if (versionFile.text != patchedFileString) {
            print("Patch " + versionFile.name)
            versionFile.write(patchedFileString)
          }
        }
      }
      return patchVersionTask
    }
  }
  if (patchVersionFilesTasks) {
    compileTaskDependencies += patchVersionFilesTasks
  }

  Task task = tasks.create(name: taskName,
                           description: taskDescription,
                           type: Task,
                           dependsOn: compileTaskDependencies).with {
    inputs.files inputFiles
    outputs.files files(outputFilesInBinaryOutputDir)
    doLast {
      exec {
        executable project.ext.xbuildExe
        workingDir projectToBuild.parentFile.absolutePath
        args ([sprintf("/target:%s", target),
               sprintf("/property:UnityHintPath=%s",
                       project.ext.unityDllPath.absolutePath),
               sprintf("/property:UnityIosPath=%s",
                       project.ext.unityIosPath.absolutePath),
               sprintf("/property:BaseIntermediateOutputPath=%s%s",
                       intermediatesDir.absolutePath,
                       File.separator),
               sprintf("/property:OutputPath=%s%s",
                       binaryOutputDir.absolutePath,
                       File.separator),
               "/verbosity:quiet",
               projectToBuild.absolutePath])
      }
    }
  }
  task.ext.buildDir = outputDir
  return task
}

/*
 * Generates tasks to compile a plugin DLL and copy it to plugin staging
 * area directory.
 *
 * @param componentName Basename of the generated tasks.
 * @param projectName Name of the project under
 * source/${projectName}/${projectName}.csproj to build.
 * @param assemblyDllBasename Basename of the output DLL generated from the
 * specified project.
 * @param versionDll Whether the output DLL filename should contain the plugin
 * version.
 * @param dependsOn List of tasks that should be completed before this plugin
 * task is executed.
 *
 * @returns Task that builds the DLL to the build output folder.
 */
Task createBuildPluginDllTask(String componentName,
                              String projectName,
                              String assemblyDllBasename,
                              Boolean versionDll,
                              Iterable<Task> dependsOn = null) {
  File projectDir = new File(project.ext.pluginSourceDir, projectName)
  File projectBuildDir = new File(project.ext.buildDir, projectName)

  // Compile the C# project.
  Task compileTask = createXbuildTask(
    sprintf("compile%s", componentName), sprintf("Compile %s", projectName),
    project.ext.pluginSolutionFile, projectName,
    fileTree(new File(projectDir, "src")), projectBuildDir,
    [new File(assemblyDllBasename)], dependsOn)
  compileTask.ext.componentName = componentName

  // Template metadata for the built DLL.
  Iterable<File> assemblyDllMetaFiles =
    compileTask.outputs.files.collect {
      new File(new File(project.ext.pluginTemplateDir,
                        project.ext.pluginEditorDllDir.path),
               it.name + project.ext.unityMetadataExtension)
    }
  // Optionally map unversioned to versioned filenames.
  Iterable<File> unversionedFiles = files(compileTask.outputs.files,
                                          assemblyDllMetaFiles)

  File stagingDir = new File(new File(projectBuildDir,
                                      project.ext.pluginStagingAreaDir.name),
                             project.ext.pluginEditorDllDir.path)
  Map<String, File> stagingFileMap =
    unversionedFiles.collectEntries { File unversionedFile ->
      File unversionedOutputFile = new File(stagingDir.path,
                                            unversionedFile.name)
      return [
        unversionedFile.path,
        versionDll ?
          versionedAssetFile(unversionedOutputFile, false, "", true) :
          unversionedOutputFile]
    }

  // Copy files to the staging directory for this project.
  Task copyTask = tasks.create(
      name: sprintf("copy%sStaging", componentName),
      type: Task,
      description: sprintf("Copy %s DLLs to the plugin staging dir.",
                         projectName),
      dependsOn: [compileTask]).with {
    inputs.files unversionedFiles
    outputs.files stagingFileMap.values()
    doLast {
      inputs.files.each {
        File inputFile ->
          copyAssetMetadataFile(inputFile, stagingFileMap[inputFile.path])
      }
    }
  }
  copyTask.ext.stagingDir = stagingDir
  copyTask.ext.componentName = componentName

  // Generate a clean target for this project.
  Task cleanTask = tasks.create(name: sprintf("clean%s", componentName),
               description: sprintf("Clean %s plugin DLL", projectName),
               type: Delete).with {
    delete (files(compileTask.outputs.files,
                  copyTask.outputs.files,
                  projectBuildDir))
  }
  cleanTask.ext.componentName = componentName

  // Return the build target for this project.
  Task buildTask =
    tasks.create(name: sprintf("build%s", componentName),
                 description: sprintf("Build %s plugin DLL",
                                      projectName),
                 dependsOn: [copyTask])
  buildTask.ext.componentName = componentName
  return buildTask
}

/*
 * Creates a task which compiles and run an NUnit test.
 *
 * @param taskName Name of the test.
 * @param description Description of the task.
 * @param dependsOn Dependencies of the new task.
 * @param unityProjectDir Directory containing a assets to copy into the
 *   integration test project.
 * @param arguments Additional arguments for Unity when running the integration
 *   test.
 * @param testType Type of the test
 * @param testModule Module of the test
 */
Task createUnityNUnitTest(String taskName,
                          String description,
                          Iterable<Task> dependsOn,
                          File unityProjectDir,
                          Iterable<String> arguments,
                          TestTypeEnum testType,
                          TestModuleEnum testModule) {
  createUnityTestBatchAndNonBatch(
    taskName,
    description,
    ["buildPlugin"],
    unityProjectDir,
    [],
    arguments + [
      "-runTests",
      "-batchmode",
      "-testResults", "results.xml",
      "-testPlatform", "EditMode"
    ], null, testType, testModule,
    true,
    new File(new File(new File(
        project.ext.scriptDirectory,
        "test_resources"),
        "nunit_upm"),
        "manifest.json"))
}

/*
 * Create a task to run an executable.
 *
 * @param name Name of the task.
 * @param description Description of the task.
 * @param dependsOn Tasks this depends upon.
 * @param executable Executable to run.
 * @param arguments Arguments for the executable.
 * @param continueOnFail Whether to ignore non-zero return code and continue.
 *
 * @returns Task which runs the specified executable.
 */
Task createExecTask(String name, String description,
                    Iterable<Task> dependsOn, File executableToRun,
                    Iterable<String> arguments, Boolean continueOnFail = false) {
  Task execTask = tasks.create(name: name,
                               description: description,
                               type: Exec,
                               dependsOn: dependsOn)
  execTask.with {
    executable executableToRun
    args arguments
    ignoreExitValue continueOnFail
  }
  return execTask
}

/*
 * Create a task that does nothing.
 *
 * @param taskName Name of the task to create.
 * @param summary Description of the task.
 * @param dependsOn Dependencies of the new task.
 *
 * @returns Task that does nothing.
 */
Task createEmptyTask(String taskName, String summary,
                     Iterable<Task> dependsOn) {
  Task emptyTask = tasks.create(name: taskName,
                                description: sprintf("(disabled) %s", summary),
                                dependsOn: dependsOn)
  emptyTask.with {
    doLast {
      logger.info(sprintf("%s disabled", taskName))
    }
  }
  return emptyTask
}

/*
 * Create a task to execute Unity.
 *
 * @param taskName Name of the task to create.
 * @param summary Description of the operation being performed with Unity.
 * "create" is a reserved operation that creates a project.  This is used to
 * generate the log file name so should be unique for the project and ideally
 * not contain whitespace.
 * @param dependsOn Dependencies of the new task.
 * @param projectName Name of the project directory to use.
 * @param projectContainerDir Directory that contains the project directory.
 * @param arguments Command line arguments to pass to Unity.
 * @param batchMode Whether to run Unity in batch mode.
 * @param createTaskClosure Optional task used to start Unity, this must
 *   conform to createExecTask()
 * @param continueOnFail Whether to ignore non-zero return code and continue.
 *
 * @returns Task which executes Unity.
 * The following extended properties are set on the task:
 * - ext.projectDir: Directory of the created Unity project.
 * - ext.containerDir: Directory which contains the Unity project and the logs.
 *   This is the same as projectContainerDir.
 * - ext.logFile: Unity log file from the operation.
 */
Task createUnityTask(String taskName, String summary,
                     Iterable<Task> dependsOn, String projectName,
                     File projectContainerDir, Iterable<String> arguments,
                     Boolean batchMode, createTaskClosure,
                     Boolean continueOnFail = false) {
  Boolean createProject = summary == "create"
  File logFile = new File(projectContainerDir,
                          sprintf("%s_%s.log", projectName, summary))
  File projectDir = new File(projectContainerDir, projectName)
  List<String> executeArguments = []

  if (batchMode) {
    executeArguments += project.ext.unityBatchModeArguments
  } else {
    executeArguments += project.ext.unityInteractiveModeArguments
  }
  executeArguments += [
    "-logFile", logFile.absolutePath,
    createProject ? "-createProject" : "-projectPath", projectDir.absolutePath]
  if (createProject) executeArguments += ["-quit"]
  executeArguments += arguments

  if (!createTaskClosure) {
    createTaskClosure = {
      String name, String description, Iterable<Task> depends,
      File executable, Iterable<String> args, Boolean contOnFail->
        return createExecTask(name,
                              description,
                              depends,
                              executable,
                              args,
                              contOnFail)
    }
  }

  Task unityTask
  if (!batchMode && !project.ext.interactiveModeTestsEnabled) {
    unityTask = createEmptyTask(taskName, summary, dependsOn)
  } else {
    unityTask = createTaskClosure(taskName,
                                  sprintf(
                                    "Run Unity to %s (project: %s)",
                                    summary, projectName),
                                  dependsOn,
                                  project.ext.unityExe,
                                  executeArguments,
                                  continueOnFail)
  }
  unityTask.with {
    outputs.files files(logFile)
  }
  unityTask.ext.projectDir = projectDir
  unityTask.ext.containerDir = projectContainerDir
  unityTask.ext.logFile = logFile
  return unityTask
}

/*
 * Create a task that generates a Unity project.
 *
 * @param taskName Name of the task.
 * @param dependsOn Dependencies of the new task.
 * @param projectName Name of the project directory to create.
 * @param projectContainerDir Directory to create the project directory in.
 *
 * @returns Task which executes Unity.
 * The following extended properties are set on the task:
 * - ext.projectDir: Directory of the created Unity project.
 * - ext.containerDir: Directory which contains the Unity project and the logs.
 *   This is the same as projectContainerDir.
 * - ext.logFile: Unity log file from the operation.
 */
Task createUnityProjectTask(String taskName, Iterable<Task> dependsOn,
                            String projectName, File projectContainerDir) {
  return createUnityTask(taskName, "create", dependsOn, projectName,
                         projectContainerDir, [], true, null).with {
    doFirst {
      // Clean / create the output directory.
      delete ext.containerDir
      ext.containerDir.mkdirs()
    }
  }
}

/*
 * Creates a task which runs a test with the Unity plugin.
 *
 * @param taskName Name of the test.
 * @param description Description of the task.
 * @param dependsOn Dependencies of the new task.
 * @param testScriptsDir Directory containing scripts to copy into the test
 *   project and execute for testing.
 * @param additionalArguments Additional arguments to pass to Unity when
 *   executing the test.
 * @param batchMode Whether to execute Unity in batch mode.
 * @param editorAssets Files to copy into the Assets/Editor folder in the
 *   project.
 * @param createTaskClosure Optional task used to start Unity, this must
 *   conform to tasks.create(name, description, type, dependsOn).
 * @param testType Type of the test
 * @param testModule Module of the test
 * @param enableDlls Whether to enable dlls through Version Handlers before tests.
 * @param upm_package_manifest Specify UPM package manifest (manifest.json)
 *
 * @returns Test task.
 */
Task createUnityTestTask(String taskName, String description,
                         Iterable<Task> dependsOn, File testScriptsDir,
                         Iterable<File> editorAssets,
                         Iterable<String> additionalArguments,
                         Boolean batchMode, createTaskClosure,
                         TestTypeEnum testType, TestModuleEnum testModule,
                         Boolean enableDlls = false,
                         File upm_package_manifest = null) {
  List<File> testScripts = []
  if (testScriptsDir) {
    testScripts = fileTree(testScriptsDir).collect {
      new File(it.absolutePath.substring(
                 testScriptsDir.absolutePath.length() + 1))
    }
  }

  // Setup the Unity project.
  List<Task> setupTasks = []
  File testOutputDir = new File(project.ext.testDir, taskName)
  Task createProject = createUnityProjectTask(
      sprintf("createsetup%s", taskName), dependsOn, taskName, testOutputDir)
  createProject.with { task ->
    inputs.files files(project.ext.pluginExportFile)
    setTestProperties(task, testType, testModule)
  }
  setupTasks += [createProject]

  Task setupTestProject = createUnityTask(
      sprintf("setup%s", taskName), "import_plugin", [createProject], taskName,
      testOutputDir, ["-importPackage", project.ext.pluginExportFile.absolutePath,
       "-quit"], batchMode, null)
  setupTestProject.with { task ->
    inputs.files (testScripts + editorAssets)
    setTestProperties(task, testType, testModule)
  }
  setupTasks += [setupTestProject]

  Task versionHandlerUpdate;
  if (enableDlls) {
    File updaterScriptDir = new File(new File(new File(
        setupTestProject.ext.projectDir,
        "Assets"),
        "Editor"),
        "VersionHandlerUpdater")
    versionHandlerUpdate = createUnityTask(
        sprintf("enableDlls%s", taskName), "enable_dlls", [setupTestProject], taskName,
        testOutputDir, [], batchMode, null)
    versionHandlerUpdate.with { task ->
      setTestProperties(task, testType, testModule)
      doFirst {
        copy {
          from new File(new File(new File(
              project.ext.scriptDirectory,
              "test_resources"),
              "version_handler_update"),
              "VersionHandlerUpdater.cs")
          into updaterScriptDir
        }
      }
      doLast {
        delete updaterScriptDir
      }
    }
    setupTasks += [versionHandlerUpdate]
  }

  List<Task> copyTasks = []

  // Task which copies test scripts into the project.
  if (testScriptsDir) {
    Task copyTestScripts = createCopyFilesTask(
      sprintf("copyScriptsFor%s", taskName),
      sprintf("Copy the test scripts into the %s Unity project.", taskName),
      testScripts, testScriptsDir, setupTestProject.ext.projectDir,
      setupTasks, null)
    copyTestScripts.with { task ->
        setTestProperties(task, testType, testModule)
    }
    copyTasks += [copyTestScripts]
  }

  if (upm_package_manifest != null) {
    Task copyPackageManifest = tasks.create(
      name: sprintf("copyPackageManifestFor%s", taskName),
      description: sprintf("Copy the package manifest into the %s Unity project.",
                          taskName),
      type: Copy,
      dependsOn: setupTasks)
    copyPackageManifest.with { task ->
      from upm_package_manifest
      into new File(setupTestProject.ext.projectDir, "Packages")
      setTestProperties(task, testType, testModule)
    }
    copyTasks += [copyPackageManifest]
  }

  // Task which copies editor scripts into the project.
  Task copyEditorAssets = tasks.create(
    name: sprintf("copyEditorAssetsFor%s", taskName),
    description: sprintf("Copy the editor assets into the %s Unity project.",
                         taskName),
    type: Copy,
    dependsOn: setupTasks)
  copyEditorAssets.with { task ->
    from editorAssets
    into new File(new File(setupTestProject.ext.projectDir, "Assets"),
                  "Editor")
    setTestProperties(task, testType, testModule)
  }
  copyTasks += [copyEditorAssets]

  // Create the test task.
  Task testTask = createUnityTask(taskName, "test",
                                  copyTasks,
                                  setupTestProject.ext.projectDir.name,
                                  setupTestProject.ext.containerDir,
                                  additionalArguments, batchMode,
                                  createTaskClosure,
                                  true)
  testTask.description = description
  testTask.with { task ->
    finalizedBy "reportAllTestsResult"
    doLast {
      EvaluateTestResult(task)
    }
    doFirst {
      ReportTestStarted(task)
    }
    setTestProperties(task, testType, testModule)
  }

  // Create a clean task
  Task cleanTestTask = tasks.create(name: sprintf("clean%s", taskName),
                                    description: sprintf("Clean %s", taskName),
                                    type: Delete).with {
    delete setupTestProject.ext.containerDir
  }

  return testTask
}

/*
 * Creates a task which runs tests with the Unity plugin in batch and
 * non-batch modes.
 *
 * @param taskName Name of the test.
 * @param description Description of the task.
 * @param dependsOn Dependencies of the new task.
 * @param testScriptsDir Directory containing scripts to copy into the test
 *   project and execute for testing.
 * @param editorAssets Files to copy into the Assets/Editor folder in the
 *   project.
 * @param additionalArguments Additional arguments to pass to Unity.
 * @param createTaskClosure Optional task used to start Unity, this must
 *   conform to tasks.create(name, description, type, dependsOn).
 * @param testType Type of the test
 * @param testModule Module of the test
 * @param enableDlls Whether to enable dlls through Version Handlers before tests.
 * @param upm_package_manifest Specify UPM package manifest (manifest.json)
 *
 * @returns Test task.
 */
Task createUnityTestBatchAndNonBatch(String taskName, String description,
                                     Iterable<Task> dependsOn,
                                     File testScriptsDir,
                                     Iterable<File> editorAssets,
                                     Iterable<String> additionalArguments,
                                     createTaskClosure,
                                     TestTypeEnum testType,
                                     TestModuleEnum testModule,
                                     Boolean enableDlls = false,
                                     File upm_package_manifest = null) {
  return tasks.create(name: taskName,
                      description: description,
                      dependsOn: [
                        createUnityTestTask(
                          sprintf("%sBatchMode", taskName),
                          sprintf("%s (Batch Mode)", description),
                          dependsOn, testScriptsDir, editorAssets,
                          additionalArguments, true, createTaskClosure,
                          testType, testModule,
                          enableDlls, upm_package_manifest),
                        createUnityTestTask(
                          sprintf("%sInteractiveMode", taskName),
                          sprintf("%s (Interactive Mode)", description),
                          dependsOn, testScriptsDir, editorAssets,
                          additionalArguments, false, createTaskClosure,
                          testType, testModule,
                          enableDlls, upm_package_manifest)])
}

/*
 * Install Python packages.
 *
 * @param taskName Name of the task to create.
 * @param description Description of the task.
 * @param dependsOn Dependencies of the new task.
 * @param packages Packages to install.
 *
 * @returns Task which executes pip to install packages
 */
Task createInstallPythonPackageTask(String taskName, String description,
                                    Iterable<Task> dependsOn,
                                    Iterable<String> packages) {
  Task installPythonPackageTask = tasks.create(
      name: taskName,
      description: sprintf("Run Pip to %s", description),
      type: Exec,
      dependsOn: dependsOn + ["build_envs"]).with {
    executable project.ext.pipExe
    args (["-q", "install"] + packages)
  }
}

/*
 * Create a task to execute Python.
 *
 * @param taskName Name of the task to create.
 * @param description Description of the task.
 * @param dependsOn Dependencies of the new task.
 * @param script Python script to run.
 * @param arguments Command line arguments to pass to the Python script.
 * @param packages Optional Python packages to install.
 * @param continueOnFail Whether to ignore non-zero return code and continue.
 *
 * @returns Task which executes Python.
 */
Task createPythonTask(String taskName, String description,
                      Iterable<Task> dependsOn,
                      File script, Iterable<String> arguments,
                      Iterable<String> packages,
                      Boolean continueOnFail = false) {
  List<Task> installPackagesTask = []
  if (packages) {
    installPackagesTask = [
      createInstallPythonPackageTask(
        taskName + "InstallPipPackages",
        sprintf("install packages %s for %s", packages.toString(), taskName),
        [],
        packages)
    ]
  }
  Task pythonTask = tasks.create(
      name: taskName,
      description: sprintf("Run Python to %s", description),
      type: Exec,
      dependsOn: (dependsOn + installPackagesTask + ["build_envs"])).with {
    ignoreExitValue continueOnFail
    executable project.ext.pythonExe
    args ([script.absolutePath] + arguments)
  }
  return pythonTask
}

/*
 * Creates a task that packages a Unity plugin with export_unity_package.py.
 *
 * @param taskName Name of the task to create.
 * @param description Description of the task.
 * @param dependsOn Dependencies of the new task.
 * @param configFile Configuration file which specifies input files.
 * @param guidsFile Optional GUIDs database file.
 * @param assetsDir Input directory for assets referenced by the configFile.
 * @param generateUnitypackage Whether to create a .unitypackage.
 * @param generateUpmTarball Whether to create a UPM tarball.
 * @param pluginsVersion Version to apply to exported plugins.
 * @param outputDir Directory to write the the exported archives.
 * @param arguments Additional arguments for export_unity_package.py
 */
Task createExportUnityPackageTask(String taskName,
                                  String description,
                                  Iterable<Task> dependsOn,
                                  File configFile,
                                  File guidsFile,
                                  File assetsDir,
                                  Boolean generateUnityPackage,
                                  Boolean generateUpmTarball,
                                  String pluginVersion,
                                  File outputDir,
                                  Iterable<String> arguments) {
  File exportScript = new File(project.ext.exportUnityPackageDir,
                               "export_unity_package.py")
  Task exportUnityPackageTask = createPythonTask(
    taskName,
    description,
    dependsOn,
    exportScript,
    ["--config_file", configFile,
     "--assets_dir", assetsDir,
     "--plugins_version", pluginVersion,
     "--output_dir", outputDir] +
    [generateUnityPackage ?
      "--output_unitypackage" : "--nooutput_unitypackage"] +
    [generateUpmTarball ? "--output_upm" : "--nooutput_upm"] +
    (guidsFile ? ["--guids_file", guidsFile] : []) +
    ["-v", "-1"] + // Only display warnings.
    arguments,
    exportUnityPackageRequirements)
  exportUnityPackageTask.with {
    inputs.files ([configFile] +
                  (guidsFile ? [guidsFile] : []) +
                  fileTree(assetsDir) +
                  [exportScript])
  }
  return exportUnityPackageTask
}

Task createGenGuidTask(String taskName,
                       String description,
                       File guidsFile,
                       String pluginVersion,
                       Iterable<String> guidPath) {
  File genGuidScript = new File(project.ext.exportUnityPackageDir,
                               "gen_guids.py")
  Task genGuidTask = createPythonTask(
    taskName,
    description,
    [],
    genGuidScript,
    ["--version", pluginVersion,
     "--guids_file", guidsFile] +
    guidPath,
    genGuidRequirements)
  genGuidTask.with {
    inputs.files ([guidsFile] +
                  [genGuidScript])
  }
  return genGuidTask
}


createUnityNUnitTest(
  "testAndroidResolverNUnitTests",
  "Runs NUnit tests for the Android Resolver module.",
  [],
  new File(project.ext.scriptDirectory,
           "source/AndroidResolver/unit_tests"), [],
           TestTypeEnum.NUNIT, TestModuleEnum.ANDROIDRESOLVER
)

task testDownloadArtifacts(type: GradleBuild) { task ->
  description "Run tests for the download_artifacts.gradle script."
  dir "source/AndroidResolver/scripts"
  setTestProperties(task, TestTypeEnum.GRADLE, TestModuleEnum.ANDROIDRESOLVER)
  doLast {
    EvaluateTestResult(task)
  }
  doFirst {
    ReportTestStarted(task)
  }
  finalizedBy "reportAllTestsResult"
}


/*
 * Report when a test starts to run
 *
 * @param testTask Task for test to start.
 */
void ReportTestStarted(Task testTask) {
  println sprintf("Test %s STARTED", testTask.name)
}

/*
 * Evaluate previously-ran test result
 *
 * @param testTask Task for previously-ran test
 */
void EvaluateTestResult(Task testTask) {
  Boolean succeeded = false
  if (testTask.class.simpleName.startsWith("Exec")) {
    if (testTask.execResult.exitValue == 0) {
      succeeded = true
    }
  } else if (testTask.class.simpleName.startsWith("DefaultTask") ||
             testTask.class.simpleName.startsWith("GradleBuild")) {
    if (testTask.state.didWork && testTask.state.failure == null) {
      succeeded = true
    }
  } else {
    throw new GradleException(
        sprintf("Unsupported test class %s", testTask.class.simpleName))
  }

  if (succeeded) {
    println sprintf("Test %s PASSED", testTask.name)
    project.ext.testSessions.add(new TestSession(
      name: testTask.name,
      type: testTask.ext.testType,
      module: testTask.ext.testModule,
      isPassed: true))
  } else {
    String errorMsg = sprintf("Test %s FAILED", testTask.name)
    println sprintf("::error::%s", errorMsg)
    project.ext.testSessions.add(new TestSession(
      name: testTask.name,
      type: testTask.ext.testType,
      module: testTask.ext.testModule,
      isPassed: false))
    if (!project.ext.continueOnFailForTestsEnabled) {
      throw new GradleException(errorMsg)
    }
  }
}

Task reportAllTestsResult = tasks.create (
  name: "reportAllTestsResult",
  description: "Report the result all every test that has been run",
  type: Task
).with {
  doLast {
    if (project.ext.testSessions.isEmpty()) {
      return
    }

    println "\n\n[Test Summary]"
    int failedCount = 0
    int totalCount = 0
    project.ext.testSessions.each { session ->
      String resultStr
      ++totalCount
      String logType = ""
      if (session.isPassed) {
        resultStr = "PASSED"
      } else {
        resultStr = "FAILED"
        logType = "::error::"
        ++failedCount
      }
      println sprintf("%sTest %s %s [%s/%s]",
          logType,
          session.name,
          resultStr,
          session.type,
          session.module)
    }
    println "--------------------------------------"
    println sprintf("::notice::%s out of %d test(s) passed", totalCount - failedCount, totalCount)
    if (failedCount > 0) {
      throw new GradleException(
        sprintf("%d out of %d test(s) failed", failedCount, totalCount))
    }
  }
}

Task testPackageUploader = createPythonTask(
  "testPackageUploader",
  "Test the unity_asset_uploader.py application.",
  [],
  new File(project.ext.unityAssetUploaderDir, "unity_asset_uploader_test.py"),
  [],
  [],
  true).with { task ->
    finalizedBy reportAllTestsResult
    doLast {
      EvaluateTestResult(task)
    }
    doFirst {
      ReportTestStarted(task)
    }
    setTestProperties(task, TestTypeEnum.PYTHON, TestModuleEnum.TOOL)
  }

createPythonTask(
  "testExportUnityPackage",
  "Test the export_unity_package.py application",
  [],
  new File(project.ext.exportUnityPackageDir, "export_unity_package_test.py"),
  [],
  exportUnityPackageRequirements,
  true).with { task ->
    setTestProperties(task, TestTypeEnum.PYTHON, TestModuleEnum.TOOL)
    finalizedBy reportAllTestsResult
    doLast {
      EvaluateTestResult(task)
    }
    doFirst {
      ReportTestStarted(task)
    }
}

createPythonTask(
  "testGenGuids",
  "Test the gen_guids.py application",
  [],
  new File(project.ext.exportUnityPackageDir, "gen_guids_test.py"),
  [],
  ["absl-py"],
  true).with { task ->
    setTestProperties(task, TestTypeEnum.PYTHON, TestModuleEnum.TOOL)
    finalizedBy reportAllTestsResult
    doLast {
      EvaluateTestResult(task)
    }
    doFirst {
      ReportTestStarted(task)
    }
  }

createPythonTask(
  "testImportUnityPackage",
  "Test the import_unity_package.py application",
  [],
  new File(project.ext.importUnityPackageDir, "import_unity_package_test.py"),
  [],
  ["absl-py"],
  true).with { task ->
    setTestProperties(task, TestTypeEnum.PYTHON, TestModuleEnum.TOOL)
    finalizedBy reportAllTestsResult
    doLast {
      EvaluateTestResult(task)
    }
    doFirst {
      ReportTestStarted(task)
    }
  }

task updateEmbeddedGradleWrapper(type: Zip) {
  description "Update the gradle wrapper in gradle-template.zip"
  from project.ext.scriptDirectory
  include "gradlew"
  include "gradlew.bat"
  include "gradle/**"
  archiveName "gradle-template.zip"
  destinationDir (new File(project.ext.scriptDirectory,
                           "source/AndroidResolver/scripts"))
}

Task buildVersionHandler = createBuildPluginDllTask(
  "VersionHandler", "VersionHandler", "Google.VersionHandler.dll", false)
Task buildVersionHandlerImpl = createBuildPluginDllTask(
  "VersionHandlerImpl", "VersionHandlerImpl", "Google.VersionHandlerImpl.dll",
  true, [buildVersionHandler])
Task buildAndroidResolver = createBuildPluginDllTask(
  "AndroidResolver", "AndroidResolver", "Google.JarResolver.dll", true,
  [updateEmbeddedGradleWrapper, buildVersionHandlerImpl])
Task buildIosResolver = createBuildPluginDllTask(
  "IosResolver", "IOSResolver", "Google.IOSResolver.dll", true,
  [buildAndroidResolver])
Task buildPackageManagerResolver = createBuildPluginDllTask(
  "PackageManagerResolver", "PackageManagerResolver",
  "Google.PackageManagerResolver.dll", true,
  [buildVersionHandlerImpl])

task preparePluginStagingAreaDir(type: Task) {
  description "Delete all files that should not be present in staging area."
  doLast {
    Set<String> excludePaths = (
      files(
        copyPluginTemplateToStagingArea.outputs.files,
        copyPluginComponentsToStagingArea.outputs.files,
        generatePluginManifest.outputs.files).files.collect {
        it.absolutePath
      }).toSet()
    fileTree(project.ext.pluginStagingAreaDir).each { fileObj ->
      if (!excludePaths.contains(fileObj.absolutePath)) {
        delete fileObj
      }
    }
  }
}

Task copyPluginTemplateToStagingArea = createCopyFilesTask(
  "copyPluginTemplateToStagingArea",
  "Copy the template project into the Unity plugin packaging dir.",
  [new File("Assets", "ExternalDependencyManager.meta"),
   new File(new File("Assets", "ExternalDependencyManager"), "Editor.meta"),
   new File(new File(new File("Assets", "ExternalDependencyManager"), "Editor"),
            "CHANGELOG.md.meta"),
   new File(new File(new File("Assets", "ExternalDependencyManager"), "Editor"),
            "LICENSE.meta"),
   new File(new File(new File("Assets", "ExternalDependencyManager"), "Editor"),
            "README.md.meta"),
   new File("Assets", "PlayServicesResolver.meta"),
   new File(new File("Assets", "PlayServicesResolver"), "Editor.meta"),
   new File(new File(new File("Assets", "PlayServicesResolver"), "Editor"),
            "play-services-resolver_v1.2.137.0.txt"),
   new File(new File(new File("Assets", "PlayServicesResolver"), "Editor"),
            "play-services-resolver_v1.2.137.0.txt.meta")],
  project.ext.pluginTemplateDir, project.ext.pluginStagingAreaDir,
  [preparePluginStagingAreaDir],
  { sourceFile, targetFile -> copyAssetMetadataFile(sourceFile, targetFile) })

Task copyDocumentationToStagingArea = createCopyFilesTask(
  "copyDocumentationToStagingArea",
  "Copy documentation into the Unity plugin packaging dir.",
  [new File("CHANGELOG.md"),
   new File("LICENSE"),
   new File("README.md")],
  project.ext.scriptDirectory,
  new File(new File(new File(project.ext.pluginStagingAreaDir, "Assets"),
                    "ExternalDependencyManager"), "Editor"),
  [preparePluginStagingAreaDir],
  { sourceFile, targetFile -> copyAssetMetadataFile(sourceFile, targetFile) })

Iterable<Task> copyComponentsToStagingAreaTasks = [
    copyAndroidResolverStaging,
    copyVersionHandlerStaging,
    copyVersionHandlerImplStaging,
    copyIosResolverStaging,
    copyPackageManagerResolverStaging].collect {
  task ->
    createCopyFilesTask(
      sprintf("copy%sToStagingArea", task.ext.componentName),
      sprintf("Copy %s into the Unity plugin packaging dir.",
              task.ext.componentName),
      task.outputs.files.collect {
        new File(it.absolutePath - task.ext.stagingDir.absolutePath)
      },
      task.ext.stagingDir,
      new File(project.ext.pluginStagingAreaDir,
               project.ext.pluginEditorDllDir.path),
      [task], null)
}

task copyPluginComponentsToStagingArea(
  dependsOn: copyComponentsToStagingAreaTasks) {
  description "Copy plugin components into the Unity plugin packaging dir."
  outputs.files files(copyComponentsToStagingAreaTasks.collect {
                        task -> task.outputs.files
                      })
}

task generatePluginManifest(dependsOn: [preparePluginStagingAreaDir,
                                        copyPluginTemplateToStagingArea,
                                        copyDocumentationToStagingArea,
                                        copyPluginComponentsToStagingArea]) {
  String unversionedManifestName = currentPluginBasename + ".txt"
  File outputDir = new File(project.ext.pluginStagingAreaDir,
                            project.ext.pluginEditorDllDir.path)
  File manifestMetadataTemplateFile =
    new File(new File(project.ext.pluginTemplateDir,
                      project.ext.pluginEditorDllDir.path),
             unversionedManifestName + project.ext.unityMetadataExtension)
  File manifestFile = versionedAssetFile(
    new File(outputDir, unversionedManifestName),
    true,
    "_manifest",
    false)
  File manifestMetadataFile = versionedAssetFile(
    new File(outputDir, manifestMetadataTemplateFile.name),
    true,
    "_manifest",
    false)

  description "Generate a manifest for the files in the plug-in."
  inputs.files files(manifestMetadataTemplateFile)
  outputs.files files(manifestFile, manifestMetadataFile)

  doLast {
    List<String> filenameList = []
    (new File(project.ext.pluginStagingAreaDir, "Assets")).eachFileRecurse(
        groovy.io.FileType.FILES) { File fileObj ->
      String absolutePath = fileObj.absolutePath
      String absolutePathLowerCase = absolutePath.toLowerCase()
      if (!(absolutePathLowerCase.endsWith(
              project.ext.unityMetadataExtension) ||
            absolutePathLowerCase.endsWith(".txt"))) {
        filenameList.add(
          absolutePath.replace(
            project.ext.pluginStagingAreaDir.absolutePath + File.separator, ""))
      }
    }
    manifestFile.write(filenameList.toSorted().join("\n") + "\n")
    copyAssetMetadataFile(manifestMetadataTemplateFile, manifestMetadataFile)
  }
}

// Deprecated target for packaging the plugin.
Task buildPluginWithUnity = createUnityTask(
    "buildPluginWithUnity", "build_plugin", [generatePluginManifest],
    project.ext.pluginStagingAreaDir.name,
    project.ext.buildDir,
    ["-g.building",
     "-buildTarget", "android",
     "-exportPackage"] + (project.ext.pluginExportDirs.collect { it.path }) +
    [project.ext.pluginExportFile.absolutePath,
     "-gvh_disable",
     "-quit"], true, null)
buildPluginWithUnity.with {
  description ("(Deprecated) Exports the plugin staging area directory as " +
               "a Unity package.")
  inputs.files files(copyPluginTemplateToStagingArea.outputs.files,
                     copyPluginComponentsToStagingArea.outputs.files)
  outputs.files files(project.ext.pluginExportFile)
}

Task buildPlugin = createExportUnityPackageTask(
  "buildPlugin",
  "Package the .unitypackage with export_unity_package.py.",
  [generatePluginManifest],
  new File(project.ext.scriptDirectory, "export_unity_package_config.json"),
  new File(project.ext.scriptDirectory, "export_unity_package_guids.json"),
  new File(project.ext.pluginStagingAreaDir, "Assets"),
  true,  // Enable .unitypackage export.
  false, // Disable UPM export.
  project.ext.pluginVersion,
  project.ext.pluginExportFile.parentFile,
  ["--enabled_sections", "unitypackage documentation"])
buildPlugin.with {
  outputs.files project.ext.pluginExportFile.absolutePath
}

// Guid paths for UPM package.
File upmPluginPackageDir = new File(currentPluginUpmPackageName, "ExternalDependencyManager")
File upmPluginEditorDir = new File(upmPluginPackageDir, "Editor")
File upmPluginDllDir = new File(upmPluginEditorDir, project.ext.pluginVersion)

Task genGuidUpm = createGenGuidTask(
  "genGuidUpm",
  "Generate GUID for .tgz packaging.",
  new File(project.ext.scriptDirectory, "export_unity_package_guids.json"),
  project.ext.pluginVersion,
  [upmPluginDllDir.path]
)

Task buildUpmPlugin = createExportUnityPackageTask(
  "buildUpmPlugin",
  "Package the .tgz with export_unity_package.py.",
  [generatePluginManifest, genGuidUpm],
  new File(project.ext.scriptDirectory, "export_unity_package_config.json"),
  new File(project.ext.scriptDirectory, "export_unity_package_guids.json"),
  new File(project.ext.pluginStagingAreaDir, "Assets"),
  false, // Disable .unitypackage export.
  true,  // Enable UPM export.
  project.ext.pluginVersion,
  project.ext.pluginUpmExportFile.parentFile,
  [])
buildUpmPlugin.with {
  outputs.files project.ext.pluginUpmExportFile.absolutePath
}

task releasePlugin(dependsOn: [buildPlugin, buildUpmPlugin]) {
  Map<File, File> pluginTemplateFilesMap = files(
      copyPluginTemplateToStagingArea.outputs.files,
      copyPluginComponentsToStagingArea.outputs.files).collectEntries {
    File inputFile ->
      return (
        inputFile.name.endsWith(project.ext.unityMetadataExtension) ?
        [inputFile,
         new File(
           project.ext.pluginTemplateDir,
           unversionedAssetFile(
             new File(inputFile.absolutePath -
                      project.ext.pluginStagingAreaDir.absolutePath)).path)] :
        [:])
  }

  description "Copy the plugin to release locations."
  inputs.files files(project.ext.pluginExportFile,
                     pluginTemplateFilesMap.keySet())
  outputs.files files(project.ext.pluginReleaseFile,
                      fileTree(dir: project.ext.pluginExplodedDir),
                      pluginTemplateFilesMap.values())
  doLast {
    // Delete and regenerate built .unitypackage in the repo.
    delete fileTree(
      dir: project.ext.pluginReleaseFile.parentFile,
      includes: [project.ext.currentPluginBasename + "-*.unitypackage"])
    copy {
      from project.ext.pluginExportFile
      into project.ext.pluginReleaseFile.parentFile
      rename { src_filename -> project.ext.pluginReleaseFile.name }
    }
    copy {
      from project.ext.pluginExportFile
      into project.ext.pluginReleaseFileUnversioned.parentFile
      rename { src_filename -> project.ext.pluginReleaseFileUnversioned.name }
    }
    // Delete and regenerate the exploded plugin folder in the repo.
    delete fileTree(dir: project.ext.pluginExplodedDir)
    copy {
      from project.ext.pluginStagingAreaDir
      into project.ext.pluginExplodedDir
      include project.ext.pluginExportDirs.collect {
        it.path + "/**/*"
      }
    }
    // Delete and regenerate the UPM package in the repo.
    delete fileTree(dir: project.ext.pluginUpmDir) 
    copy {
      // Rename the top-level package folder to upm.
      eachFile {
        path = path.replaceFirst(/^.+?\//, "upm/")
      }  
      from tarTree(project.ext.pluginUpmExportFile)
      into project.ext.scriptDirectory
    }
    pluginTemplateFilesMap.each {
      sourceFile, targetFile -> copyFile(sourceFile, targetFile)
    }
    println sprintf("Packaged to %s", project.ext.pluginReleaseFile)
  }
}

task gitAddReleaseFilesToStaging(type: Exec, dependsOn: releasePlugin) {
  description "Run git to add release to the staging area."
  commandLine "git", "add", "-A"
}

/*
 * Read the changes applied to the current version from the changelog.
 *
 * @returns Version summary in a multiline string.
 */
String readVersionSummaryFromChangelog() {
  String versionSummary = ""
  Boolean foundVersion = false
  for (String line in project.ext.changelog.text.tokenize("\n")) {
    String trimmedLine = line.trim()
    if (line =~ /^# Version/) {
      if (foundVersion) break
      foundVersion = true
    }
    versionSummary += line.replace("#", "-") + "\n"
  }
  return versionSummary
}

/*
 * Create a commit message for a release commit.
 *
 * @returns Commit message string.
 */
String createCommitMessage() {
  return sprintf("Version %s\n\n%s",
                 project.ext.pluginVersion,
                 readVersionSummaryFromChangelog())
}

task gitCreateReleaseCommit(dependsOn: gitAddReleaseFilesToStaging) {
  description "Run git to create a release commit."

  doLast {
    def stdout = new ByteArrayOutputStream()
    exec {
      commandLine "git", "status", "-s"
      ignoreExitValue true
      standardOutput = stdout
    }
    if (!stdout.toString().isEmpty()) {
      exec {
        commandLine "git", "commit", "-a", "-m", createCommitMessage()
      }
    }
  }
}

task gitTagRelease(type: Exec) {
  description ("Run git to tag a release.  This should be performed " +
               "*after* a release commit has been be created.")
  commandLine "git", "tag", "-a",
              sprintf("v%s", pluginVersion), "-m",
              sprintf("%s\n\nDownload [here](%s)",
                      createCommitMessage(),
                      sprintf("https://github.com/googlesamples/" +
                              "unity-jar-resolver/raw/v%s/" +
                              "external-dependency-manager-%s.unitypackage",
                              project.ext.pluginVersion,
                              project.ext.pluginVersion))
}

// TODO: Version Handler tests
// - Per platform targeting (iOS, Android, Editor, desktop)
// - Version enablement, import newer plugin on top of older plugin and validate
//   new plugin is enabled, old plugin is removed.
// - Linux library renaming (need to override LibraryPrefix to test)
// - Canonical filename renaming for versioned filenames
// - Change settings, restore default settings.
// - Import plugin into a project and wait for asset processor to enable it.
// - Switch .NET version, validate DLLs are enabled / disabled as expected.

// TODO: Android Resolver tests
// - Resolve with:
//   - Conflicting dependencies
//   - FAT ABI vs. single ABI selection

// TODO: iOS Resolver tests (on OSX only)
// - Import plugin test Cocoapods bootstrap
// - Pod specification, with reflection & XML, validate both are present in the
//   set.
// - Workspace export (Unity 5.6 and above)
// - Project export
// - Add a pod which changes the target SDK

createUnityNUnitTest(
  "testVersionHandlerImplNUnitTests",
  "Runs NUnit tests for the VersionHandlerImpl module.",
  [],
  new File(project.ext.scriptDirectory,
           "source/VersionHandlerImpl/unit_tests"), [],
           TestTypeEnum.NUNIT, TestModuleEnum.VERSIONHANDLER
)

createUnityNUnitTest(
  "testPackageManagerResolverNUnitTests",
  "Runs NUnit tests for the PackageManagerResolver module.",
  [],
  new File(project.ext.scriptDirectory,
           "source/PackageManagerResolver/unit_tests"), [],
           TestTypeEnum.NUNIT, TestModuleEnum.PACKAGEMANAGER
)

createUnityTestBatchAndNonBatch(
  "testVersionHandlerActivation",
  ("Imports the plugin into a Unity project and verifies all " +
   "components can be activated by the Version Handler."),
  [buildPlugin],
  new File(project.ext.scriptDirectory,
           "source/VersionHandlerImpl/test/activation"),
  [], [], null, TestTypeEnum.INTEGRATION, TestModuleEnum.VERSIONHANDLER)

// Launch the test via a script that runs a local web server.
createUnityTestBatchAndNonBatch(
  "testVersionHandlerWebRequest",
  ("Imports the plugin into a Unity project tests the PortableWebRequest " +
   "class."),
  [buildPlugin],
  new File(project.ext.scriptDirectory,
           "source/VersionHandlerImpl/test/webrequest"),
  [], [],
  { String name, String description, Iterable<Task> depends,
    File executable, Iterable<String> args, Boolean continueOnFail ->
      Iterable<String> runnerArgs = [executable.absolutePath] + args
      return createPythonTask(
        name, description, depends,
        new File(
          new File(
            new File(project.ext.pluginSourceDir,
                     "VersionHandlerImpl"),
            "test"),
          "webrequest_launcher.py"),
        runnerArgs,
        [], continueOnFail)
  }, TestTypeEnum.INTEGRATION, TestModuleEnum.CORE)

createUnityTestBatchAndNonBatch(
  "testVersionHandlerReflection",
  ("Imports the plugin into a Unity project and tests reflection " +
   "methods."),
  [buildPlugin],
  new File(project.ext.scriptDirectory,
           "source/VersionHandler/test/reflection"),
  [],
  [],
  null,
  TestTypeEnum.INTEGRATION, TestModuleEnum.CORE)

Task compileIntegrationTester = createXbuildTask(
  "compileIntegrationTester",
  "Compile Integration Tester module.",
  project.ext.pluginSolutionFile,
  "IntegrationTester",
  fileTree(new File(project.ext.pluginSourceDir,
                    "IntegrationTester")),
  new File(project.ext.buildDir, "IntegrationTester"),
  [new File("Google.IntegrationTester.dll")],
  [compileVersionHandler])

/*
 * Creates a task which compiles and run a Unity integration test.
 *
 * @param taskName Name of the test.
 * @param description Description of the task.
 * @param dependsOn Dependencies of the new task.
 * @param integrationTestProject Project within
 *   project.ext.pluginSolutionFile that contains the integration test.
 * @param integrationTestProjectSources Source files integrationTestProject
 *  requires.
 * @param integrationTestProjectOutputs Assemblies generated by the
 *   integrationTestProject.
 * @param unityProjectDir Directory containing a assets to copy into the
 *   integration test project.
 * @param arguments Additional arguments for Unity when running the integration
 *   test.
 * @param testType Type of the test
 * @param testModule Module of the test
 */
Task createUnityIntegrationTest(String taskName,
                                String description,
                                Iterable<Task> dependsOn,
                                String integrationTestProject,
                                Iterable<File> integrationTestProjectSources,
                                Iterable<File> integrationTestProjectOutputs,
                                File unityProjectDir,
                                Iterable<String> arguments,
                                TestTypeEnum testType,
                                TestModuleEnum testModule) {
  Task compileIntegrationTest = createXbuildTask(
    sprintf("compile%s", integrationTestProject),
    sprintf("Compile %s for %s", integrationTestProject, taskName),
    project.ext.pluginSolutionFile,
    integrationTestProject,
    integrationTestProjectSources,
    new File(project.ext.buildDir, integrationTestProject),
    integrationTestProjectOutputs,
    [compileIntegrationTester] + dependsOn)
  compileIntegrationTest.with { task ->
    setTestProperties(task, testType, testModule)
  }

  createUnityTestBatchAndNonBatch(
    taskName,
    description,
    [buildPlugin],
    unityProjectDir,
    compileIntegrationTest.outputs.files +
    compileIntegrationTester.outputs.files,
    arguments, null, testType, testModule)
}

createUnityIntegrationTest(
  "testAndroidResolverIntegrationTests",
  ("Imports the plugin into a Unity project, runs Android resolution with " +
   "a combination of dependencies added via the programmatic API and via " +
   "XML files, verifying all dependencies resolve successfully."),
  [compileAndroidResolver],
  "AndroidResolverIntegrationTests",
  fileTree(new File(new File(project.ext.pluginSourceDir, "AndroidResolver"),
                    "test")),
  [new File("Google.AndroidResolverIntegrationTests.dll")],
  new File(
    project.ext.scriptDirectory,
    "source/AndroidResolver/test/AndroidResolverIntegrationTestsUnityProject"),
  ["-buildTarget", "android"],
  TestTypeEnum.INTEGRATION,
  TestModuleEnum.ANDROIDRESOLVER)

createUnityIntegrationTest(
  "testPackageManagerClientIntegrationTests",
  ("Imports the plugin into a Unity project and uses the Unity Package " +
   "Manager client to list, search, install and remove packages. "),
  [compilePackageManagerResolver],
  "PackageManagerClientIntegrationTests",
  fileTree(new File(new File(new File(project.ext.pluginSourceDir,
                             "PackageManagerResolver"), "test"),
                    "PackageManagerClientIntegrationTests")),
  [new File("Google.PackageManagerClientIntegrationTests.dll"),
   new File("Google.PackageManagerClientIntegrationTests.dll.mdb")],
  null, [],
  TestTypeEnum.INTEGRATION,
  TestModuleEnum.PACKAGEMANAGER)

task cleanTests(type: Delete) {
  description "Clean test directories."
  delete project.ext.testDir
}

task cleanAll(type: Delete) {
  description "Clean the build directory."
  delete project.ext.buildDir
}

project.defaultTasks = ["build", "test", "release", "clean"].collect {
  topLevelTaskName ->
    tasks.create(name: topLevelTaskName,
                 description: sprintf("Run all %s tasks",
                                      topLevelTaskName),
                 type: Task,
                 dependsOn: project.tasks.findAll {
                   task -> task.name.startsWith(topLevelTaskName)
                 })
}

// Disable tests by filters.
project.tasks.findAll { task ->
  if (task.hasProperty("testType") && task.testType != null &&
     task.hasProperty("testModule") && task.testModule != null) {
    if (!shouldTestRunWithFilters(task.testType, task.testModule)) {
      println sprintf("DISABLED :%s", task.name)
      task.enabled = false
    }
    if (project.ext.excludeTestsParam.contains(task.name.toLowerCase())) {
      println sprintf("DISABLED :%s", task.name)
      task.enabled = false
    }
  }
}
